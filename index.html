<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Cartas - CS</title>
    <style>
        /* Estilos CSS embebidos */
        body {
            font-family: 'Inter', sans-serif; /* Usamos Inter como se sugiere */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1a1a; /* Fondo casi negro para elegancia */
            color: #ffffff; /* Texto blanco puro */
            overflow: hidden; /* Evita el scroll si el contenido es un poco más grande */
        }

        .game-screen {
            display: none; /* Ocultar todas las pantallas por defecto */
            flex-direction: column;
            align-items: center;
            padding: 25px; /* Más padding para un look más espacioso */
            border: 1px solid #FF0000; /* Borde fino rojo */
            border-radius: 0; /* Bordes rectos */
            background-color: #222222; /* Fondo gris muy oscuro */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5); /* Sombra más sutil */
            width: 90%;
            max-width: 550px; /* Un poco más ancho */
            box-sizing: border-box;
            gap: 20px; /* Más espacio entre elementos */
        }

        .game-screen.active {
            display: flex; /* Mostrar solo la pantalla activa */
        }

        h1 {
            color: #FF0000; /* Título rojo */
            margin-bottom: 25px; /* Más margen */
            text-align: center;
            font-size: 2.2em; /* Título más grande */
            text-transform: uppercase; /* Mayúsculas para un look más limpio */
            letter-spacing: 2px; /* Espaciado entre letras */
        }

        .input-group {
            margin-bottom: 20px; /* Más margen */
            width: 100%;
            text-align: center;
        }

        label {
            display: block;
            margin-bottom: 10px; /* Más margen */
            font-size: 1.15em; /* Texto de label más grande */
            color: #cccccc; /* Gris suave para labels */
        }

        input[type="text"] {
            padding: 15px; /* Más padding */
            width: calc(100% - 30px); /* Ajuste para padding */
            border: 1px solid #555555; /* Borde de input gris oscuro */
            border-radius: 0; /* Bordes rectos */
            background-color: #333333; /* Fondo de input más oscuro */
            color: #ffffff; /* Texto blanco */
            font-size: 1.1em; /* Fuente de input más grande */
            margin-bottom: 15px; /* Más margen */
            box-sizing: border-box;
        }

        button {
            padding: 14px 30px; /* Más padding */
            background-color: #FF0000; /* Botón rojo */
            color: #ffffff; /* Texto blanco */
            border: none;
            border-radius: 0; /* Bordes rectos */
            cursor: pointer;
            font-size: 1.1em; /* Fuente de botón más grande */
            font-weight: bold;
            text-transform: uppercase; /* Mayúsculas */
            letter-spacing: 1px; /* Espaciado entre letras */
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4); /* Sombra sutil */
        }

        button:hover {
            background-color: #CC0000; /* Rojo más oscuro al pasar el ratón */
            transform: translateY(-1px); /* Menos movimiento */
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.5);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        }

        .error-message {
            color: #ff4d4d; /* Rojo de error ligeramente más brillante */
            margin-top: 10px;
            font-weight: bold;
            text-align: center;
            font-size: 1em;
        }

        /* Estilos para la pantalla de juego (screen3) */
        #screen3 {
            width: 100%;
            max-width: 1200px;
            height: 95vh;
            display: grid;
            grid-template-rows: 1fr 2fr 1fr;
            gap: 20px; /* Más espacio entre secciones */
            padding: 15px;
            background-color: #1a1a1a; /* Fondo que coincide con el body */
            border: none;
            box-shadow: none;
        }

        .player-area {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 15px;
            border: 1px solid #333333; /* Borde muy sutil */
            border-radius: 0; /* Bordes rectos */
            background-color: #2b2b2b; /* Fondo gris oscuro */
            box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.2); /* Sombra interior muy sutil */
        }

        .opponent-area {
            order: 1;
            flex-direction: column;
            position: relative;
        }

        .own-area {
            order: 3;
            flex-direction: column;
            position: relative;
        }

        /* Nuevo estilo para el tablero lineal */
        .board-area {
            order: 2;
            display: flex; /* Usar flexbox para la línea de casillas */
            justify-content: space-between; /* Espacio entre casillas */
            align-items: center;
            background-color: #1a1a1a;
            border: 1px solid #FF0000;
            border-radius: 0;
            position: relative;
            width: 100%;
            max-width: 900px; /* Ancho máximo para el tablero lineal */
            height: 80px; /* Altura fija para la línea */
            margin: auto;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
            padding: 0 10px; /* Pequeño padding horizontal */
        }

        /* Estilos para las manos y los mazos/descartes */
        .hand {
            display: flex;
            gap: 15px; /* Más espacio entre cartas */
            min-height: 200px; /* Espacio para cartas más grandes */
            border: none; /* Sin borde */
            padding: 10px;
            border-radius: 0;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .deck-discard-area {
            display: flex;
            gap: 40px; /* Más espacio */
            margin-top: 20px;
            justify-content: center;
            align-items: center;
        }

        .deck, .discard-pile {
            width: 140px; /* Cartas más grandes */
            height: 200px; /* Cartas más grandes */
            border: 1px solid #555555; /* Borde sutil */
            background-color: #333333; /* Fondo oscuro */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em; /* Texto más grande */
            color: #cccccc;
            border-radius: 0; /* Bordes rectos */
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            cursor: pointer;
        }

        /* Estilo para el envés de la carta del rival */
        .opponent-hand .card-back {
            background-color: #000000; /* Negro sólido */
            color: #ffffff;
            width: 130px; /* Ligeramente más pequeña que la propia */
            height: 190px;
            border-radius: 0; /* Bordes rectos */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5em; /* Letras CS más grandes */
            font-weight: bold;
            border: 1px solid #444444; /* Borde sutil */
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        /* Estilos para la carta en mano del jugador */
        .card-in-hand {
            width: 140px; /* Cartas más grandes */
            height: 200px; /* Cartas más grandes */
            background-color: #ffffff; /* Fondo blanco para las cartas */
            border: 1px solid #333333; /* Borde sutil */
            border-radius: 0; /* Bordes rectos */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); /* Sombra más pronunciada */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease, z-index 0s 0.3s;
            position: relative;
            z-index: 1;
        }

        .card-in-hand:hover {
            transform: translateY(-15px) scale(1.25); /* Zoom y elevación más pronunciados */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); /* Sombra más grande al hacer zoom */
            z-index: 20;
        }

        .card-image {
            width: 100%;
            height: 55%; /* Ocupa más espacio */
            background-color: #f0f0f0; /* Fondo más claro para la imagen */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9em; /* Texto más grande */
            color: #666666; /* Gris más oscuro */
            border-bottom: 1px solid #e0e0e0; /* Borde más claro */
        }

        .card-info {
            padding: 10px; /* Más padding */
            font-size: 0.9em; /* Texto más grande */
            color: #333333; /* Texto oscuro */
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            justify-content: space-between;
        }

        .card-name-value {
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px; /* Más espacio */
            font-size: 1.1em; /* Nombre y valor más grandes */
        }

        .card-effect {
            font-size: 0.8em; /* Texto de efecto más grande */
            line-height: 1.4;
            color: #555555; /* Gris para el efecto */
        }

        /* Estilo para la última carta jugada */
        .last-played-card {
            width: 140px;
            height: 200px;
            background-color: #ffffff;
            border: 1px solid #333333;
            border-radius: 0;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Posicionamiento de los nombres de jugador */
        #ownNameDisplay, #opponentNameDisplay {
            font-size: 1.5em; /* Nombres más grandes */
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 15px; /* Más margen */
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Botón de pasar turno */
        .game-button {
            margin-top: 25px; /* Más margen */
            align-self: center;
        }

        .game-message {
            text-align: center;
            font-size: 1.3em; /* Mensajes más grandes */
            font-weight: bold;
            margin-top: 20px;
            color: #FFD700; /* Amarillo dorado para mensajes de juego, contrasta bien */
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.3); /* Sombra sutil para el mensaje */
        }

        /* Estilos para las casillas del tablero lineal */
        .board-cell {
            width: 55px; /* Ancho de cada casilla */
            height: 55px; /* Altura de cada casilla */
            background-color: #333333;
            border: 1px solid #555555;
            border-radius: 0; /* Cuadradas */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.1em; /* Texto más grande */
            font-weight: bold;
            color: #ffffff;
            box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.3);
            position: relative; /* Para posicionar los tokens dentro */
        }

        /* Estilos para los jugadores en el tablero */
        .player-token {
            position: absolute;
            width: 35px;
            height: 35px;
            border-radius: 0; /* Cuadrados */
            border: 2px solid #ffffff;
            box-shadow: 0 0 6px rgba(0, 0, 0, 0.6);
            z-index: 10;
            top: 50%; /* Centrar verticalmente */
            transform: translateY(-50%);
        }

        .player1-token {
            background-color: #e74c3c; /* Rojo */
            left: 5px; /* Pequeño offset para P1 */
        }

        .player2-token {
            background-color: #3498db; /* Azul */
            right: 5px; /* Pequeño offset para P2 */
        }

        /* Opciones al clicar una carta */
        .card-options {
            position: absolute;
            background-color: #2b2b2b; /* Fondo oscuro */
            border: 1px solid #FF0000; /* Borde rojo */
            border-radius: 0; /* Bordes rectos */
            padding: 12px; /* Más padding */
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px; /* Más espacio */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .card-options button {
            width: 100%;
            padding: 10px 18px; /* Más padding */
            font-size: 1em; /* Fuente más grande */
            background-color: #FF0000;
            color: #ffffff;
            text-transform: uppercase;
        }

        /* Estilos para el modal y el overlay */
        .modal-overlay {
            display: none; /* Oculto por defecto */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Fondo oscuro semitransparente */
            backdrop-filter: blur(5px); /* Efecto de desenfoque */
            z-index: 1000; /* Por encima de todo */
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #222222; /* Fondo gris oscuro */
            border: 1px solid #FF0000; /* Borde rojo */
            border-radius: 0; /* Bordes rectos */
            padding: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.6);
            text-align: center;
            max-width: 90%;
            width: 600px; /* Ancho fijo para el modal */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .modal-content h2 {
            color: #FF0000;
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        .modal-body {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            max-height: 400px; /* Altura máxima para el scroll */
            overflow-y: auto; /* Scroll si el contenido es demasiado grande */
            padding-right: 10px; /* Espacio para la barra de scroll */
        }

        .modal-body .card-in-hand {
            /* Reutilizar estilos de carta, pero ajustarlos para el modal si es necesario */
            width: 120px; /* Un poco más pequeñas en el modal */
            height: 170px;
            cursor: default; /* No clicables en el modal de visualización */
            transform: none; /* Eliminar hover effects */
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .modal-body .card-in-hand:hover {
            transform: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .modal-buttons button {
            padding: 12px 25px;
            font-size: 1em;
            background-color: #FF0000;
            color: #ffffff;
            border: none;
            border-radius: 0;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .modal-buttons button:hover {
            background-color: #CC0000;
        }


        /* Media Queries para responsividad */
        @media (max-width: 768px) {
            .game-screen {
                padding: 15px;
                max-width: 95%;
            }

            h1 {
                font-size: 1.6em;
                margin-bottom: 15px;
            }

            label {
                font-size: 1em;
            }

            input[type="text"], button {
                padding: 10px;
                font-size: 0.9em;
            }

            #screen3 {
                grid-template-rows: auto 1fr auto;
                height: auto;
                min-height: 95vh;
                padding: 10px;
                gap: 10px;
            }

            .player-area, .deck-discard-area {
                flex-direction: column;
                gap: 8px;
                padding: 8px;
            }

            .hand {
                min-height: 160px;
                gap: 10px;
            }

            .card-in-hand, .last-played-card, .opponent-hand .card-back {
                width: 100px;
                height: 140px;
            }
            .deck, .discard-pile {
                width: 100px;
                height: 140px;
            }
            .card-image {
                height: 50%;
            }
            .card-info {
                padding: 6px;
                font-size: 0.75em;
            }
            .card-name-value {
                font-size: 1em;
                margin-bottom: 4px;
            }
            .card-effect {
                font-size: 0.7em;
                line-height: 1.3;
            }
            .board-cell {
                width: 40px;
                height: 40px;
                font-size: 0.8em;
            }
            .player-token {
                width: 28px;
                height: 28px;
            }
            #ownNameDisplay, #opponentNameDisplay {
                font-size: 1.2em;
                margin-bottom: 8px;
            }
            .game-button {
                margin-top: 15px;
                padding: 10px 20px;
            }
            .game-message {
                font-size: 1em;
                margin-top: 15px;
            }
            .card-options {
                padding: 8px;
                gap: 5px;
            }
            .card-options button {
                padding: 8px 12px;
                font-size: 0.85em;
            }
            /* Media queries para el modal en pantallas pequeñas */
            .modal-content {
                padding: 20px;
                width: 95%;
            }
            .modal-content h2 {
                font-size: 1.5em;
            }
            .modal-body {
                gap: 10px;
            }
            .modal-body .card-in-hand {
                width: 90px;
                height: 120px;
            }
            .modal-buttons {
                flex-direction: column;
                gap: 10px;
            }
            .modal-buttons button {
                padding: 10px 20px;
                font-size: 0.9em;
            }
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
</head>
<body>

    <div id="screen1" class="game-screen active">
        <h1>¡Bienvenido a CS Cards!</h1>
        <div class="input-group">
            <label for="playerName">Introduce tu nombre:</label>
            <input type="text" id="playerName" placeholder="Tu nombre">
            <button id="btnEnterName">Aceptar</button>
        </div>
        <div class="input-group">
            <label for="rivalNameScreen1">Introduce el nombre de tu rival:</label>
            <input type="text" id="rivalNameScreen1" placeholder="Nombre del rival">
        </div>
        <p id="nameError" class="error-message"></p>
        <p id="rivalErrorScreen1" class="error-message"></p>
    </div>

    <div id="screen3" class="game-screen">
        <div class="player-area opponent-area">
            <span id="opponentNameDisplay">Rival</span>
            <div class="hand opponent-hand" id="opponentHand">
            </div>
            <div class="deck-discard-area">
                <div class="deck" id="deck">Mazo</div>
                <div class="discard-pile" id="discardPile">Descarte</div>
            </div>
        </div>

        <div class="board-area" id="gameBoard">
            </div>

        <div class="player-area own-area">
            <span id="ownNameDisplay">Tú</span>
            <div class="hand own-hand" id="ownHand">
            </div>
            <button id="btnPassTurn" class="game-button">Pasar Turno</button>
        </div>
        <p id="gameMessage" class="game-message"></p>
    </div>

    <div id="cardInteractionModal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="modalTitle"></h2>
            <div id="modalBody" class="modal-body"></div>
            <div id="modalButtons" class="modal-buttons"></div>
        </div>
    </div>

    <script>
        // Tu configuración de Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyAfK_AOq-Pc2bzgXEzIEZ1ESWvnhMJUvwI",
            authDomain: "enraya-51670.firebaseapp.com",
            databaseURL: "https://enraya-51670-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "enraya-51670",
            storageBucket: "enraya-51670.firebasestorage.app",
            messagingSenderId: "103343380727",
            appId: "1:103343380727:web:b2fa02aee03c9506915bf2",
            measurementId: "G-2G31LLJY1T"
        };

        // Inicializar Firebase
        // Usamos firebase-app-compat y firebase-auth-compat para compatibilidad
        const app = firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();

        // Referencias a los elementos de las pantallas
        const screen1 = document.getElementById('screen1');
        const screen3 = document.getElementById('screen3');

        const playerNameInput = document.getElementById('playerName');
        const btnEnterName = document.getElementById('btnEnterName');
        const nameError = document.getElementById('nameError');

        // Elementos del rival ahora en screen1
        const rivalNameInputScreen1 = document.getElementById('rivalNameScreen1');
        const rivalErrorScreen1 = document.getElementById('rivalErrorScreen1');

        const ownNameDisplay = document.getElementById('ownNameDisplay');
        const opponentNameDisplay = document.getElementById('opponentNameDisplay');
        const opponentHandDiv = document.getElementById('opponentHand');
        const ownHandDiv = document.getElementById('ownHand');
        const gameBoardDiv = document.getElementById('gameBoard');
        const discardPileDiv = document.getElementById('discardPile');
        const gameMessageDiv = document.getElementById('gameMessage');

        // Referencias a los elementos del modal
        const cardInteractionModal = document.getElementById('cardInteractionModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        const modalButtons = document.getElementById('modalButtons');


        // Variables globales para los nombres de los jugadores y el estado de la partida
        let currentPlayerName = '';
        let rivalPlayerName = '';
        let currentUserId = ''; // UID de Firebase para el jugador actual
        let currentRivalId = ''; // UID de Firebase para el rival
        let currentRoomId = ''; // ID del documento de la sala en Firestore
        let unsubscribeSnapshot = null; // Para desuscribirse de los listeners de Firestore

        // Definición de las cartas
        const cardDefinitions = [
            { id: 'muerte', name: 'Muerte', value: -4.9, effect: 'Elige a un jugador, ese jugador pone sus cartas boca abajo y tú descartas 1 de las cartas. Si esa carta vale 0 o menos, avanzas 1 casilla.', count: 1, image: 'https://placehold.co/90x65/000000/FFFFFF?text=Muerte+-4.9' },
            { id: 'avefenix', name: 'Ave Fénix', value: -3.3, effect: 'Descarta tu mano y roba 3 cartas.', count: 1, image: 'https://placehold.co/90x65/FF4500/000000?text=Ave+Fenix+-3.3' },
            { id: 'gato', name: 'Gato', value: -3, effect: 'Roba 2 cartas.', count: 1, image: 'https://placehold.co/90x65/8B4513/FFFFFF?text=Gato+-3' },
            { id: 'caballodetroya', name: 'Caballo de Troya', value: -2.6, effect: 'Elige a un jugador, ese jugador elige 1 de sus cartas y la descarta.', count: 1, image: 'https://placehold.co/90x65/A9A9A9/000000?text=Caballo+Troya+-2.6' },
            { id: 'ranadelasuerte', name: 'Rana de la Suerte', value: -2, effect: 'Avanza 2 casillas.', count: 1, image: 'https://placehold.co/90x65/32CD32/FFFFFF?text=Rana+-2' },
            { id: 'perro', name: 'Perro', value: -4, effect: 'El siguiente jugador pierde su turno.', count: 1, image: 'https://placehold.co/90x65/CD853F/FFFFFF?text=Perro+-4' },
            { id: 'esclavo', name: 'Esclavo', value: -1, effect: 'Si tienes una carta mayor que 4, puedes mostrarla para avanzar 1 casilla.', count: 2, image: 'https://placehold.co/90x65/696969/FFFFFF?text=Esclavo+-1' },
            { id: 'loco', name: 'Loco', value: -0.5, effect: 'Elige a un jugador, ambos mostráis 1 de vuestras cartas, la más alta gana. Ambas cartas son descartadas. El jugador ganador avanza 2 casillas y el perdedor retrocede 1.', count: 1, image: 'https://placehold.co/90x65/800080/FFFFFF?text=Loco+-0.5' },
            { id: 'vagabundo', name: 'Vagabundo', value: 0, effect: 'Compara tu carta más baja con la carta más baja de otro jugador, si tu carta es más baja, avanza 2 casillas.', count: 3, image: 'https://placehold.co/90x65/D2B48C/000000?text=Vagabundo+0' },
            { id: 'filosofo', name: 'Filósofo', value: 0.5, effect: 'Elige a un jugador, ambos robáis una carta y la mostráis, si tu carta es más alta, te la quedas y el otro jugador descarta la carta robada. Si tu carta es más baja, ambos jugadores descartáis las cartas robadas.', count: 1, image: 'https://placehold.co/90x65/F0E68C/000000?text=Filosofo+0.5' },
            { id: 'nini', name: 'Nini', value: 1, effect: 'Roba 1 carta.', count: 5, image: 'https://placehold.co/90x65/ADD8E6/000000?text=Nini+1' },
            { id: 'influencer', name: 'Influencer', value: 2, effect: 'Compara tu carta más alta con la carta más alta del jugador que elijas. El ganador avanza 1 casilla, el perdedor retrocede 1 casilla.', count: 3, image: 'https://placehold.co/90x65/FFD700/000000?text=Influencer+2' },
            { id: 'camello', name: 'Camello', value: 2.1, effect: 'Roba 1 carta, descarta 1 carta. Si muestras una carta de -1 o menor, avanza 1 casilla.', count: 1, image: 'https://placehold.co/90x65/8B4513/FFFFFF?text=Camello+2.1' },
            { id: 'trabajador', name: 'Trabajador', value: 3, effect: 'Avanza 1 casilla.', count: 5, image: 'https://placehold.co/90x65/A52A2A/FFFFFF?text=Trabajador+3' },
            { id: 'artesano', name: 'Artesano', value: 3.1, effect: 'Si estás en la casilla 0, 1, 2 o 3, avanza 2 casillas. Si estás en la 4 o superior, avanza 1.', count: 1, image: 'https://placehold.co/90x65/BDB76B/000000?text=Artesano+3.1' },
            { id: 'policia', name: 'Policía', value: 4, effect: 'Elige 1 jugador, ese jugador retrocede 1 casilla.', count: 4, image: 'https://placehold.co/90x65/1E90FF/FFFFFF?text=Policia+4' },
            { id: 'detective', name: 'Detective', value: 4.7, effect: 'Elige a un jugador y una carta, si ese jugador tiene esa carta: la muestra y retrocede 2 casillas.', count: 1, image: 'https://placehold.co/90x65/D2691E/FFFFFF?text=Detective+4.7' },
            { id: 'guardaespaldas', name: 'Guardaespaldas', value: 4.9, effect: 'Hasta tu próximo turno, las cartas del resto de jugadores, no te afectan.', count: 2, image: 'https://placehold.co/90x65/4682B4/FFFFFF?text=Guardaespaldas+4.9' },
            { id: 'abogado', name: 'Abogado', value: 5, effect: 'Intercambia las cartas con otro jugador.', count: 3, image: 'https://placehold.co/90x65/6A5ACD/FFFFFF?text=Abogado+5' },
            { id: 'banquero', name: 'Banquero', value: 5.9, effect: 'Si la última carta jugada es igual o mayor que 7, avanzas 2 casillas.', count: 1, image: 'https://placehold.co/90x65/DAA520/000000?text=Banquero+5.9' },
            { id: 'musico', name: 'Músico', value: 6, effect: 'Roba 2 cartas y descarta 2 cartas.', count: 2, image: 'https://placehold.co/90x65/FF6347/FFFFFF?text=Musico+6' },
            { id: 'arlequin', name: 'Arlequín', value: 6.4, effect: 'Roba 2 cartas y descarta 1.', count: 1, image: 'https://placehold.co/90x65/800000/FFFFFF?text=Arlequin+6.4' },
            { id: 'futbolista', name: 'Futbolista', value: 6.7, effect: 'Descarta 1 carta para avanzar 2 casillas.', count: 1, image: 'https://placehold.co/90x65/008000/FFFFFF?text=Futbolista+6.7' },
            { id: 'capo', name: 'Capo', value: 7, effect: 'Avanzas 1 casilla. Elige un jugador, el jugador elegido retrocede 1 casilla.', count: 2, image: 'https://placehold.co/90x65/8B0000/FFFFFF?text=Capo+7' },
            { id: 'politico', name: 'Político', value: 8, effect: 'Un jugador, (puedes ser tú), descarta sus cartas y roba la misma cantidad. Avanzas 1 casilla.', count: 1, image: 'https://placehold.co/90x65/483D8B/FFFFFF?text=Politico+8' },
            { id: 'sectario', name: 'Sectario', value: 9, effect: 'Elige un jugador y mira sus cartas, puedes intercambiar tus cartas por las suyas. Avanzas 1 casilla.', count: 1, image: 'https://placehold.co/90x65/2F4F4F/FFFFFF?text=Sectario+9' },
            { id: 'astronauta', name: 'Astronauta', value: 10.5, effect: 'Avanza 1 casilla. Si estás en la casilla 8 o superior, roba 1 carta.', count: 1, image: 'https://placehold.co/90x65/708090/FFFFFF?text=Astronauta+10.5' },
            // Mago y Titán excluidos por ahora
            { id: 'arcangel', name: 'Arcángel', value: 12, effect: 'Avanza 1 casilla. Roba 3 cartas y descarta 2.', count: 1, image: 'https://placehold.co/90x65/FFD700/000000?text=Arcangel+12' },
            { id: 'semidios', name: 'Semidiós', value: 13, effect: 'Avanza 1 casilla. Repite tu turno.', count: 1, image: 'https://placehold.co/90x65/DAA520/000000?text=Semidios+13' },
            { id: 'ojotodove', name: 'Ojo que todo lo ve', value: 13.9, effect: 'Avanza 1 casilla. Mira las cartas de todos los jugadores.', count: 1, image: 'https://placehold.co/90x65/8A2BE2/FFFFFF?text=Ojo+Ve+13.9' }
        ];

        // Función para cambiar de pantalla
        function showScreen(screenToShow) {
            screen1.classList.remove('active');
            screen3.classList.remove('active');
            screenToShow.classList.add('active');
        }

        // Función para generar una carta visualmente
        function createCardElement(card, isFaceDown = false) {
            const cardDiv = document.createElement('div');
            cardDiv.classList.add('card-in-hand');
            cardDiv.dataset.cardId = card.id; // Almacenar el ID de la carta

            if (isFaceDown) {
                cardDiv.classList.add('card-back');
                cardDiv.innerHTML = 'CS';
            } else {
                cardDiv.innerHTML = `
                    <div class="card-image" style="background-image: url('${card.image}'); background-size: cover; background-position: center;"></div>
                    <div class="card-info">
                        <div class="card-name-value">
                            <span>${card.name}</span>
                            <span>${card.value}</span>
                        </div>
                        <div class="card-effect">${card.effect}</div>
                    </div>
                `;
            }
            return cardDiv;
        }

        // Función para renderizar la mano del jugador
        function renderOwnHand(hand) {
            console.log("Rendering own hand with card IDs:", hand); // Añadido para depuración
            ownHandDiv.innerHTML = '';
            hand.forEach(cardId => {
                const card = cardDefinitions.find(c => c.id === cardId);
                if (card) {
                    const cardElement = createCardElement(card);
                    cardElement.addEventListener('click', () => showCardOptions(cardElement, card));
                    ownHandDiv.appendChild(cardElement);
                } else {
                    console.warn("Card definition not found for ID:", cardId); // Añadido para depuración
                }
            });
        }

        // Función para renderizar la mano del oponente (boca abajo)
        function renderOpponentHand(numCards) {
            console.log("Rendering opponent hand with", numCards, "cards (face down)."); // Añadido para depuración
            opponentHandDiv.innerHTML = '';
            for (let i = 0; i < numCards; i++) {
                opponentHandDiv.appendChild(createCardElement({}, true)); // isFaceDown = true
            }
        }

        // Función para mostrar las opciones de una carta (jugar/nada)
        function showCardOptions(cardElement, card) {
            // Eliminar opciones anteriores si existen
            const existingOptions = document.querySelector('.card-options');
            if (existingOptions) {
                existingOptions.remove();
            }

            const optionsDiv = document.createElement('div');
            optionsDiv.classList.add('card-options');
            optionsDiv.style.left = `${cardElement.offsetLeft}px`;
            optionsDiv.style.top = `${cardElement.offsetTop - optionsDiv.offsetHeight - 10}px`; // Ajustar posición

            const playButton = document.createElement('button');
            playButton.textContent = 'Jugar';
            playButton.addEventListener('click', () => {
                playCard(card.id);
                optionsDiv.remove();
            });

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Nada';
            cancelButton.addEventListener('click', () => {
                optionsDiv.remove();
            });

            optionsDiv.appendChild(playButton);
            optionsDiv.appendChild(cancelButton);
            ownHandDiv.appendChild(optionsDiv); // Añadir al contenedor de la mano para posicionamiento relativo

            // Ajustar la posición después de añadirlo al DOM para que el offsetHeight sea correcto
            optionsDiv.style.top = `${cardElement.offsetTop - optionsDiv.offsetHeight - 10}px`;
            optionsDiv.style.left = `${cardElement.offsetLeft + (cardElement.offsetWidth / 2) - (optionsDiv.offsetWidth / 2)}px`;

            // Cerrar opciones si se clica fuera
            const closeOptions = (event) => {
                if (!optionsDiv.contains(event.target) && !cardElement.contains(event.target)) {
                    optionsDiv.remove();
                    document.removeEventListener('click', closeOptions);
                }
            };
            document.addEventListener('click', closeOptions);
        }


        // Función para renderizar el tablero lineal
        function renderGameBoard(player1Pos, player2Pos) {
            gameBoardDiv.innerHTML = ''; // Limpiar casillas existentes
            const numCells = 14; // De 0 a 13

            for (let i = 0; i < numCells; i++) {
                const cell = document.createElement('div');
                cell.classList.add('board-cell');
                cell.textContent = i;
                cell.dataset.cellIndex = i; // Almacenar el índice de la casilla
                gameBoardDiv.appendChild(cell);
            }

            // Renderizar tokens de jugador
            const player1Token = document.createElement('div');
            player1Token.classList.add('player-token', 'player1-token');
            player1Token.id = 'player1Token';
            gameBoardDiv.appendChild(player1Token);

            const player2Token = document.createElement('div');
            player2Token.classList.add('player-token', 'player2-token');
            player2Token.id = 'player2Token';
            gameBoardDiv.appendChild(player2Token);

            updatePlayerTokens(player1Pos, player2Pos);
        }

        // Función para actualizar la posición de los tokens de jugador en el tablero lineal
        function updatePlayerTokens(player1Pos, player2Pos) {
            const player1Token = document.getElementById('player1Token');
            const player2Token = document.getElementById('player2Token');
            const cells = gameBoardDiv.querySelectorAll('.board-cell');

            if (cells.length > 0) {
                // Posicionar Jugador 1
                const cell1 = cells[player1Pos];
                player1Token.style.left = `${cell1.offsetLeft + (cell1.offsetWidth / 2) - (player1Token.offsetWidth / 2) - 10}px`; /* Ajuste para P1 */
                player1Token.style.top = `${cell1.offsetTop + (cell1.offsetHeight / 2) - (player1Token.offsetHeight / 2)}px`;

                // Posicionar Jugador 2 (ligeramente desplazado si están en la misma casilla)
                const cell2 = cells[player2Pos];
                let offset = 0;
                if (player1Pos === player2Pos) {
                    offset = 10; // Pequeño desplazamiento para que no se superpongan completamente
                }
                player2Token.style.left = `${cell2.offsetLeft + (cell2.offsetWidth / 2) - (player2Token.offsetWidth / 2) + offset}px`; /* Ajuste para P2 */
                player2Token.style.top = `${cell2.offsetTop + (cell2.offsetHeight / 2) - (player2Token.offsetHeight / 2)}px`;
            }
        }

        // Helper function to draw a card, handling reshuffling
        function drawCardForTurn(mazo, pilaDescarte, messageDiv) {
            if (mazo.length === 0) {
                if (pilaDescarte.length > 0) {
                    mazo.push(...shuffleArray(pilaDescarte));
                    pilaDescarte.length = 0;
                    messageDiv.textContent = '¡Mazo barajado con el descarte!';
                } else {
                    messageDiv.textContent = 'No hay cartas en el mazo ni en el descarte para robar.';
                    return null;
                }
            }
            return mazo.shift();
        }

        // --- Lógica de Firebase y Partida ---

        // Función para iniciar sesión anónimamente y obtener el UID
        async function signInAnonymouslyAndGetUid() {
            try {
                const userCredential = await auth.signInAnonymously();
                currentUserId = userCredential.user.uid;
                console.log('Autenticado anónimamente con UID:', currentUserId);
            } catch (error) {
                console.error('Error al autenticar anónimamente:', error);
                gameMessageDiv.textContent = 'Error de autenticación. Por favor, recarga la página.';
            }
        }

        // Función para buscar o crear una sala
        async function findOrCreateRoom(player1Name, player2Name) {
            try {
                const roomsRef = db.collection('SALAS');
                // Buscar salas donde los nombres de los jugadores coincidan en cualquier orden
                const query1 = roomsRef.where('jugador1Nombre', '==', player1Name)
                                      .where('jugador2Nombre', '==', player2Name);
                const query2 = roomsRef.where('jugador1Nombre', '==', player2Name)
                                      .where('jugador2Nombre', '==', player1Name);

                const [snapshot1, snapshot2] = await Promise.all([query1.get(), query2.get()]);

                let roomDoc = null;

                if (!snapshot1.empty) {
                    roomDoc = snapshot1.docs[0];
                } else if (!snapshot2.empty) {
                    roomDoc = snapshot2.docs[0];
                }

                if (roomDoc) {
                    // Sala existente, unirse a ella
                    currentRoomId = roomDoc.id;
                    const roomData = roomDoc.data();
                    const roomRef = db.collection('SALAS').doc(currentRoomId);

                    // Determinar si el jugador actual es el jugador1 o jugador2 en la sala existente
                    if (roomData.jugador1Nombre === currentPlayerName && roomData.jugador1Id === null) {
                        // Si el jugador 1 de la sala no tiene ID, asignárselo (caso de reconexión o error previo)
                        await roomRef.update({
                            jugador1Id: currentUserId,
                            'estadoJuego.gameStatus': roomData.jugador2Id ? 'inProgress' : 'waitingForPlayer',
                            [`estadoJuego.drawStatus.${currentUserId}`]: false // Initialize draw status for player1 if rejoining
                        });
                        gameMessageDiv.textContent = 'Te has reconectado como Jugador 1.';
                        currentRivalId = roomData.jugador2Id;
                    } else if (roomData.jugador2Nombre === currentPlayerName && roomData.jugador2Id === null) {
                        // Si el jugador 2 de la sala no tiene ID, asignárselo (caso de reconexión o error previo)
                        await roomRef.update({
                            jugador2Id: currentUserId,
                            'estadoJuego.gameStatus': 'inProgress',
                            'estadoJuego.turnoActual': Math.random() < 0.5 ? roomData.jugador1Id : currentUserId,
                            [`estadoJuego.drawStatus.${currentUserId}`]: false // Initialize draw status for player2
                        });
                        gameMessageDiv.textContent = '¡Te has unido a la partida!';
                        currentRivalId = roomData.jugador1Id;
                    } else if (roomData.jugador1Id === currentUserId || roomData.jugador2Id === currentUserId) {
                        // El jugador ya está en la sala y tiene su ID asignado
                        gameMessageDiv.textContent = 'Reconectando a la partida existente.';
                        if (roomData.jugador1Id === currentUserId) {
                            currentRivalId = roomData.jugador2Id;
                        } else {
                            currentRivalId = roomData.jugator1Id;
                        }
                        // Ensure drawStatus exists for rejoining player if not already
                        if (!roomData.estadoJuego.drawStatus || roomData.estadoJuego.drawStatus[currentUserId] === undefined) {
                            await roomRef.update({
                                [`estadoJuego.drawStatus.${currentUserId}`]: false
                            });
                        }
                    } else {
                        // La sala existe pero no es para este jugador o ya está llena
                        console.error('Error: Intentando unirse a una sala que ya está llena o no te corresponde.');
                        rivalError.textContent = 'La sala ya está completa o no te corresponde. Intenta con otro nombre de rival.';
                        return; // Evitar mostrar screen3
                    }

                    listenToRoomChanges(currentRoomId);
                    showScreen(screen3);
                } else {
                    // No existe sala, crear una nueva
                    console.log("No existing room found, creating a new one.");
                    const initialDeck = generateInitialDeck();
                    const shuffledDeck = shuffleArray(initialDeck);
                    const initialHand1 = shuffledDeck.splice(0, 3);
                    const initialHand2 = shuffledDeck.splice(0, 3); // Mano inicial para el jugador 2 (vacía si no se unió)

                    const newRoomRef = await roomsRef.add({
                        jugador1Id: currentUserId,
                        jugador1Nombre: player1Name,
                        jugador2Id: null, // Inicialmente nulo
                        jugador2Nombre: player2Name, // Guardar el nombre del rival esperado
                        estadoJuego: {
                            mazo: shuffledDeck,
                            pilaDescarte: [],
                            manoJugador1: initialHand1,
                            manoJugador2: initialHand2,
                            posicionJugador1: 0,
                            posicionJugador2: 0,
                            ultimaCartaJugada: null,
                            turnoActual: null, // Se asignará cuando el segundo jugador se una
                            gameStatus: "waitingForPlayer",
                            ganador: null,
                            efectosActivos: {},
                            drawStatus: { [currentUserId]: false } // Inicializar drawStatus para el jugador 1
                        }
                    });
                    currentRoomId = newRoomRef.id;
                    console.log('Sala creada:', currentRoomId);
                    gameMessageDiv.textContent = 'Esperando al rival... (ID de sala: ' + currentRoomId + ')'; // Mostrar ID para depuración
                    listenToRoomChanges(currentRoomId);
                    showScreen(screen3);
                }
            } catch (error) {
                console.error('Error al buscar/crear sala:', error);
                rivalErrorScreen1.textContent = 'Error al conectar. Inténtalo de nuevo.';
            }
        }

        // Función para escuchar cambios en la sala de Firestore
        function listenToRoomChanges(roomId) {
            if (unsubscribeSnapshot) {
                unsubscribeSnapshot(); // Desuscribirse del listener anterior si existe
            }
            const roomRef = db.collection('SALAS').doc(roomId);
            unsubscribeSnapshot = roomRef.onSnapshot(docSnapshot => {
                if (docSnapshot.exists) {
                    const roomData = docSnapshot.data();
                    console.log('Estado de la sala actualizado (onSnapshot):', roomData);
                    console.log('currentUserId (desde onSnapshot):', currentUserId);

                    // Determinar currentRivalId y nombres de forma robusta
                    if (roomData.jugador1Id === currentUserId) {
                        currentRivalId = roomData.jugador2Id;
                        currentPlayerName = roomData.jugador1Nombre;
                        rivalPlayerName = roomData.jugador2Nombre;
                    } else if (roomData.jugador2Id === currentUserId) {
                        currentRivalId = roomData.jugador1Id;
                        currentPlayerName = roomData.jugador2Nombre;
                        rivalPlayerName = roomData.jug1Nombre;
                    } else {
                        currentRivalId = null;
                        console.error("Error: currentUserId no coincide con ningún jugador en la sala. Esto no debería ocurrir si el jugador está en una sala activa.");
                        // Forzar a volver a la pantalla de inicio si el estado es inconsistente
                        gameMessageDiv.textContent = 'Error en la conexión. Volviendo a la pantalla de inicio.';
                        showScreen(screen1);
                        return;
                    }

                    // Actualizar la UI con los últimos datos de la sala
                    updateGameUI(roomData, roomRef);

                    // Lógica para transiciones de estado del juego y mensajes
                    if (roomData.estadoJuego.gameStatus === "waitingForPlayer") {
                        gameMessageDiv.textContent = 'Esperando al rival... (ID de sala: ' + roomId + ')';
                        btnPassTurn.disabled = true;

                        // Si es el jugador 1, el rival se ha unido y el turno no está asignado, iniciar partida
                        if (roomData.jugador1Id === currentUserId && roomData.jugador2Id && !roomData.estadoJuego.turnoActual) {
                            console.log("Jugador 1 detectó que Jugador 2 se unió. Inicializando estado de juego y turno.");
                            roomRef.update({
                                'estadoJuego.gameStatus': 'inProgress',
                                'estadoJuego.turnoActual': Math.random() < 0.5 ? roomData.jugador1Id : roomData.jugador2Id,
                                [`estadoJuego.drawStatus.${roomData.jugador1Id}`]: false, // Reset draw status for both players on game start
                                [`estadoJuego.drawStatus.${roomData.jugador2Id}`]: false
                            }).then(() => {
                                console.log("Estado de juego y turno actualizados por Jugador 1.");
                                gameMessageDiv.textContent = '¡Rival conectado! La partida ha comenzado.';
                            }).catch(error => {
                                console.error('Error al actualizar estado de juego y turno:', error);
                            });
                        }
                    } else if (roomData.estadoJuego.gameStatus === "inProgress") {
                        // El mensaje de turno se maneja en updateGameUI
                        console.log("Juego en progreso. Turno actual:", roomData.estadoJuego.turnoActual);
                    } else if (roomData.estadoJuego.gameStatus === "finished") {
                        gameMessageDiv.textContent = `¡Partida terminada! El ganador es: ${roomData.estadoJuego.ganador === currentUserId ? currentPlayerName : rivalPlayerName}`;
                        btnPassTurn.disabled = true; // Deshabilitar interacciones
                        // Opcional: mostrar botón de nueva partida
                    }

                } else {
                    console.log('La sala ya no existe.');
                    gameMessageDiv.textContent = 'La partida ha terminado o la sala ha sido eliminada.';
                    showScreen(screen1); // Volver a la pantalla de nombres
                }
            }, error => {
                console.error('Error al escuchar cambios en la sala:', error);
                gameMessageDiv.textContent = 'Error de conexión. Volviendo a la pantalla de selección de rival.';
                showScreen(screen1); // Volver a la pantalla de nombres
            });
        }

        // Función para actualizar la UI del juego con los datos de Firestore
        async function updateGameUI(roomData, roomRef) {
            const gameState = roomData.estadoJuego;

            // Actualizar nombres
            const ownName = roomData.jugador1Id === currentUserId ? roomData.jugador1Nombre : roomData.jugador2Nombre;
            const opponentName = roomData.jugador1Id === currentUserId ? roomData.jugador2Nombre : roomData.jugador1Nombre;
            ownNameDisplay.textContent = ownName;
            opponentNameDisplay.textContent = opponentName;
            console.log(`UI Nombres - Propio: ${ownNameDisplay.textContent}, Rival: ${opponentNameDisplay.textContent}`);


            // Actualizar manos
            const ownHand = roomData.jugador1Id === currentUserId ? gameState.manoJugador1 : gameState.manoJugador2;
            const opponentHandCount = roomData.jugador1Id === currentUserId ? gameState.manoJugador2.length : gameState.manoJugador1.length;
            renderOwnHand(ownHand);
            renderOpponentHand(opponentHandCount);

            // Actualizar pila de descarte
            discardPileDiv.innerHTML = '';
            if (gameState.ultimaCartaJugada) {
                const lastCard = cardDefinitions.find(c => c.id === gameState.ultimaCartaJugada);
                if (lastCard) {
                    const lastCardElement = createCardElement(lastCard);
                    lastCardElement.classList.add('last-played-card');
                    discardPileDiv.appendChild(lastCardElement);
                }
            } else {
                discardPileDiv.textContent = 'Descarte';
            }

            // Actualizar tablero y posiciones de jugadores
            const player1Pos = gameState.posicionJugador1;
            const player2Pos = gameState.posicionJugador2;
            renderGameBoard(player1Pos, player2Pos); // Pasar las posiciones tal cual están en Firestore

            // Indicar turno actual y manejar robo de carta al inicio del turno
            console.log(`DEBUG: UI Turno - Turno actual en Firestore: ${gameState.turnoActual}, Mi UID: ${currentUserId}, Rival UID: ${currentRivalId}`);
            console.log(`DEBUG: UI Turno - drawStatus para ${currentUserId}: ${gameState.drawStatus ? gameState.drawStatus[currentUserId] : 'undefined'}`);
            console.log(`DEBUG: UI Turno - gameStatus: ${gameState.gameStatus}`);

            if (gameState.turnoActual === currentUserId) {
                gameMessageDiv.textContent = '¡Es tu turno!';
                btnPassTurn.disabled = false; // Habilitar botón de pasar turno
                ownHandDiv.style.border = '2px solid #FF0000'; // Resaltar mano del jugador actual con rojo

                // Lógica para robar carta al inicio del turno
                if (gameState.gameStatus === "inProgress" && gameState.drawStatus && gameState.drawStatus[currentUserId] === false) {
                    console.log("DEBUG: UI Turno - Detectado que el jugador actual necesita robar una carta.");
                    const currentMazo = [...gameState.mazo]; // Copia para modificar
                    const currentPilaDescarte = [...gameState.pilaDescarte]; // Copia para modificar
                    const currentOwnHand = [...ownHand]; // Copia para modificar

                    const newCard = drawCardForTurn(currentMazo, currentPilaDescarte, gameMessageDiv);
                    if (newCard) {
                        currentOwnHand.push(newCard);
                        console.log(`DEBUG: UI Turno - Carta robada: ${newCard}. Nueva mano:`, currentOwnHand);

                        // Actualizar Firestore con la nueva mano, mazo, descarte y estado de robo
                        const updatePayload = {
                            'estadoJuego.mazo': currentMazo,
                            'estadoJuego.pilaDescarte': currentPilaDescarte,
                            [`estadoJuego.drawStatus.${currentUserId}`]: true // Marcar como robado para este turno
                        };

                        if (roomData.jugador1Id === currentUserId) {
                            updatePayload['estadoJuego.manoJugador1'] = currentOwnHand;
                        } else {
                            updatePayload['estadoJuego.manoJugador2'] = currentOwnHand;
                        }

                        try {
                            await roomRef.update(updatePayload);
                            gameMessageDiv.textContent += ' Has robado una carta al inicio de tu turno.';
                            console.log("DEBUG: UI Turno - Firestore actualizado después de robar carta.");
                        } catch (e) {
                            console.error("Error al actualizar Firestore después de robar carta:", e);
                        }
                    } else {
                        console.log("DEBUG: UI Turno - No se pudo robar una carta.");
                    }
                }

            } else if (gameState.turnoActual === currentRivalId) {
                gameMessageDiv.textContent = `Turno de ${opponentNameDisplay.textContent}`;
                btnPassTurn.disabled = true; // Deshabilitar botón de pasar turno
                ownHandDiv.style.border = '1px solid #333333'; // Quitar resaltado con un borde sutil
            } else {
                 gameMessageDiv.textContent = 'Esperando al rival...';
                 btnPassTurn.disabled = true;
                 ownHandDiv.style.border = '1px solid #333333';
            }

            // Verificar condición de victoria
            if (gameState.posicionJugador1 >= 13 || gameState.posicionJugador2 >= 13) {
                const winnerId = gameState.posicionJugador1 >= 13 ? roomData.jugador1Id : roomData.jugador2Id;
                // Solo actualiza el estado de la partida a "finished" si aún no lo está
                if (gameState.gameStatus !== "finished") {
                    if (roomRef) { // Asegurarse de que roomRef esté disponible antes de actualizar
                        roomRef.update({ 'estadoJuego.ganador': winnerId, 'estadoJuego.gameStatus': 'finished' });
                        console.log("DEBUG: Condición de victoria alcanzada. Ganador:", winnerId);
                    } else {
                        console.error("roomRef no está disponible para actualizar el estado de victoria.");
                    }
                }
            }
        }

        // Función para generar el mazo inicial completo
        function generateInitialDeck() {
            let deck = [];
            cardDefinitions.forEach(card => {
                for (let i = 0; i < card.count; i++) {
                    deck.push(card.id);
                }
            });
            return deck;
        }

        // Función para barajar un array (algoritmo Fisher-Yates)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // --- Lógica de Juego (acciones del jugador) ---

        // Función para jugar una carta
        async function playCard(cardId) {
            // Asegurarse de que es el turno del jugador
            const roomRef = db.collection('SALAS').doc(currentRoomId);
            const roomDoc = await roomRef.get();
            const roomData = roomDoc.data();
            const gameState = roomData.estadoJuego;

            if (gameState.turnoActual !== currentUserId) {
                gameMessageDiv.textContent = '¡No es tu turno!';
                console.log("DEBUG: playCard - No es tu turno.");
                return;
            }
            console.log(`DEBUG: playCard - Jugando carta: ${cardDefinitions.find(c => c.id === cardId).name}`);
            gameMessageDiv.textContent = `Jugando ${cardDefinitions.find(c => c.id === cardId).name}...`;

            let ownHand = roomData.jugador1Id === currentUserId ? [...gameState.manoJugador1] : [...gameState.manoJugador2];
            let rivalHand = roomData.jugador1Id === currentUserId ? [...gameState.manoJugador2] : [...gameState.manoJugador1];
            let ownPos = roomData.jugador1Id === currentUserId ? gameState.posicionJugador1 : gameState.posicionJugador2;
            let rivalPos = roomData.jugador1Id === currentUserId ? gameState.posicionJugador2 : gameState.posicionJugador1;
            let mazo = [...gameState.mazo];
            let pilaDescarte = [...gameState.pilaDescarte];
            const lastPlayedCardId = gameState.ultimaCartaJugada;
            let effectsActivos = {...gameState.efectosActivos}; // Copy effects

            const cardIndex = ownHand.indexOf(cardId);
            if (cardIndex === -1) {
                gameMessageDiv.textContent = 'Esa carta no está en tu mano.';
                console.log("DEBUG: playCard - Carta no encontrada en mano.");
                return;
            }

            const playedCard = cardDefinitions.find(c => c.id === cardId);
            ownHand.splice(cardIndex, 1); // Remover la carta de la mano
            pilaDescarte.push(cardId); // Añadirla a la pila de descarte

            // Crear un objeto de estado mutable para pasar a applyCardEffect
            let mutableState = {
                ownHand: ownHand,
                rivalHand: rivalHand,
                ownPos: ownPos,
                rivalPos: rivalPos,
                mazo: mazo,
                pilaDescarte: pilaDescarte,
                lastPlayedCardId: lastPlayedCardId,
                currentUserId: currentUserId,
                currentRivalId: currentRivalId,
                roomData: roomData,
                roomRef: roomRef,
                effectsActivos: effectsActivos // Pass effects to mutableState
            };

            // Aplicar efecto de la carta, modificando mutableState
            await applyCardEffect(playedCard, mutableState);

            // Determinar el próximo turno. Si la carta es Semidiós, el turno se repite.
            let nextTurnPlayerId = currentRivalId;
            let newDrawStatus = {...gameState.drawStatus}; // Copy drawStatus

            if (playedCard.id === 'semidios') {
                nextTurnPlayerId = currentUserId; // Repetir turno
                newDrawStatus[currentUserId] = false; // Reset draw status for repeated turn
                console.log("DEBUG: playCard - Semidiós jugado. Repitiendo turno y reseteando drawStatus para el jugador actual.");
            } else {
                newDrawStatus[currentRivalId] = false; // Reset draw status for the next player
                console.log("DEBUG: playCard - Turno normal. Reseteando drawStatus para el rival.");
            }

            // Actualizar el estado en Firestore con los valores modificados de mutableState
            let updatedGameState = {
                ...gameState,
                mazo: mutableState.mazo,
                pilaDescarte: mutableState.pilaDescarte,
                ultimaCartaJugada: cardId,
                manoJugador1: roomData.jugador1Id === currentUserId ? mutableState.ownHand : mutableState.rivalHand,
                manoJugador2: roomData.jugador1Id === currentUserId ? mutableState.rivalHand : mutableState.ownHand,
                posicionJugador1: roomData.jugador1Id === currentUserId ? mutableState.ownPos : mutableState.rivalPos,
                posicionJugador2: roomData.jugador1Id === currentUserId ? mutableState.rivalPos : mutableState.ownPos,
                turnoActual: nextTurnPlayerId, // Pasar el turno al rival o repetir
                efectosActivos: mutableState.effectsActivos, // Update effects from mutableState
                drawStatus: newDrawStatus // Update drawStatus
            };
            console.log("DEBUG: playCard - Estado del juego a actualizar en Firestore:", updatedGameState);

            await roomRef.update({ estadoJuego: updatedGameState });
            gameMessageDiv.textContent = `Has jugado ${playedCard.name}. Turno de ${opponentNameDisplay.textContent}.`;
        }

        // Función auxiliar para elegir un jugador (simplificado por ahora)
        // NOTA: Para una experiencia multijugador completa, esto debería ser un modal interactivo
        // que permita al jugador actual elegir entre sí mismo o el rival, y que el rival reciba una notificación.
        async function choosePlayer() {
            console.log("DEBUG: choosePlayer llamado. Por simplicidad, siempre se elige al rival.");
            // Por ahora, siempre elegimos al rival para efectos que afectan a "otro jugador".
            // Para efectos donde se puede elegir "a ti mismo o a otro", se necesitaría una UI.
            return currentRivalId;
        }

        // Función auxiliar para elegir una carta de la mano (simplificado por ahora)
        // NOTA: Para una experiencia multijugador completa, si el rival debe elegir una carta,
        // esto debería involucrar una interacción en la UI del rival y una actualización en Firestore.
        async function chooseCardFromHand(hand) {
            console.log("DEBUG: chooseCardFromHand llamado. Por simplicidad, se elige la primera carta.");
            // Por ahora, simplemente elige la primera carta disponible en la mano.
            // Si la mano está vacía, devuelve null.
            if (hand && hand.length > 0) {
                return hand[0];
            }
            return null;
        }

        // Función para aplicar los efectos de las cartas
        async function applyCardEffect(card, state) {
            // Desestructurar el estado para facilitar el acceso y la modificación
            let { ownHand, rivalHand, ownPos, rivalPos, mazo, pilaDescarte, lastPlayedCardId, currentUserId, currentRivalId, roomData, roomRef, effectsActivos } = state;
            const isPlayer1 = roomData.jugador1Id === currentUserId;

            console.log(`DEBUG: applyCardEffect - Aplicando efecto de carta: ${card.name}`);
            console.log("DEBUG: applyCardEffect - Estado inicial del efecto:", { ownHand: [...ownHand], rivalHand: [...rivalHand], ownPos, rivalPos, mazo: [...mazo], pilaDescarte: [...pilaDescarte], effectsActivos: {...effectsActivos} });

            // Función auxiliar para robar cartas, manejando el barajado del descarte (para efectos)
            const drawCardForEffect = () => {
                if (mazo.length === 0) {
                    if (pilaDescarte.length > 0) {
                        mazo.push(...shuffleArray(pilaDescarte));
                        pilaDescarte.length = 0; // Vaciar pila de descarte
                        gameMessageDiv.textContent = '¡Mazo barajado con el descarte!';
                        console.log("DEBUG: drawCardForEffect - Mazo barajado con descarte. Nuevo mazo:", mazo);
                    } else {
                        gameMessageDiv.textContent = 'No hay cartas en el mazo ni en el descarte para robar.';
                        console.log("DEBUG: drawCardForEffect - No hay cartas para robar.");
                        return null; // No hay cartas para robar
                    }
                }
                const drawnCard = mazo.shift(); // Roba la primera carta del mazo
                console.log("DEBUG: drawCardForEffect - Carta robada:", drawnCard);
                return drawnCard;
            };

            // Función auxiliar para descartar cartas (simplificado: descarta la última)
            // NOTA: Para permitir al jugador elegir qué carta descartar, se necesitaría una interfaz de usuario interactiva (modal).
            const discardCards = (hand, count) => {
                console.log(`DEBUG: discardCards - Intentando descartar ${count} cartas de la mano:`, hand);
                for (let i = 0; i < count; i++) {
                    if (hand.length > 0) {
                        const discardedCard = hand.pop(); // Descarta la última carta
                        pilaDescarte.push(discardedCard);
                        console.log("DEBUG: discardCards - Carta descartada:", discardedCard);
                    } else {
                        console.log("DEBUG: discardCards - No hay más cartas en la mano para descartar.");
                        break;
                    }
                }
            };

            // Función para mostrar un modal interactivo
            function showModal(title, contentHtml, buttons) {
                return new Promise(resolve => {
                    modalTitle.textContent = title;
                    modalBody.innerHTML = ''; // Limpiar contenido previo
                    modalBody.appendChild(contentHtml); // Añadir el contenido HTML proporcionado

                    modalButtons.innerHTML = ''; // Limpiar botones previos
                    buttons.forEach(btn => {
                        const buttonElement = document.createElement('button');
                        buttonElement.textContent = btn.text;
                        buttonElement.addEventListener('click', () => {
                            hideModal();
                            resolve(btn.action); // Resolver la promesa con la acción del botón
                        });
                        modalButtons.appendChild(buttonElement);
                    });

                    cardInteractionModal.style.display = 'flex'; // Mostrar el modal
                });
            }

            // Función para ocultar el modal
            function hideModal() {
                cardInteractionModal.style.display = 'none';
                modalTitle.textContent = '';
                modalBody.innerHTML = '';
                modalButtons.innerHTML = '';
            }


            switch (card.id) {
                case 'muerte':
                    console.log("DEBUG: Efecto Muerte activado.");
                    const chosenOpponentIdMuerte = await choosePlayer(); // Elegir rival
                    let opponentHandToDiscardFromMuerte = (isPlayer1 && chosenOpponentIdMuerte === currentRivalId) ? rivalHand : ownHand;
                    const discardedCardIdMuerte = await chooseCardFromHand(opponentHandToDiscardFromMuerte); // Elegir primera carta del rival

                    if (discardedCardIdMuerte) {
                        const index = opponentHandToDiscardFromMuerte.indexOf(discardedCardIdMuerte);
                        if (index > -1) {
                            opponentHandToDiscardFromMuerte.splice(index, 1);
                            pilaDescarte.push(discardedCardIdMuerte);
                            const discardedCardMuerte = cardDefinitions.find(c => c.id === discardedCardIdMuerte);
                            gameMessageDiv.textContent = `${(chosenOpponentIdMuerte === currentUserId ? ownNameDisplay.textContent : opponentNameDisplay.textContent)} ha descartado ${discardedCardMuerte.name}.`;
                            console.log("DEBUG: Muerte: Carta descartada del rival:", discardedCardMuerte.name);

                            if (discardedCardMuerte.value <= 0) {
                                ownPos = Math.min(13, ownPos + 1);
                                gameMessageDiv.textContent += ' ¡Has avanzado 1 casilla!';
                                console.log("DEBUG: Muerte: Avanza 1 casilla. Nueva posición:", ownPos);
                            }
                        }
                    }
                    if (isPlayer1 && chosenOpponentIdMuerte === currentRivalId) { rivalHand = opponentHandToDiscardFromMuerte; } else if (chosenOpponentIdMuerte === currentUserId) { ownHand = opponentHandToDiscardFromMuerte; }
                    break;

                case 'avefenix':
                    console.log("DEBUG: Efecto Ave Fénix activado.");
                    discardCards(ownHand, ownHand.length); // Discard all cards
                    ownHand.length = 0; // Ensure hand is empty after discarding
                    for (let i = 0; i < 3; i++) {
                        const newCard = drawCardForEffect();
                        if (newCard) ownHand.push(newCard);
                    }
                    gameMessageDiv.textContent = 'Has descartado tu mano y robado 3 cartas.';
                    console.log("DEBUG: Ave Fénix: Mano actualizada:", ownHand);
                    break;

                case 'gato':
                    console.log("DEBUG: Efecto Gato activado.");
                    for (let i = 0; i < 2; i++) {
                        const newCard = drawCardForEffect();
                        if (newCard) ownHand.push(newCard);
                    }
                    gameMessageDiv.textContent += ' Has robado 2 cartas.';
                    console.log("DEBUG: Gato: Mano actualizada:", ownHand);
                    break;

                case 'caballodetroya':
                    console.log("DEBUG: Efecto Caballo de Troya activado.");
                    const targetPlayerIdTroya = await choosePlayer(); // Elegir rival
                    let targetHandTroya = (isPlayer1 && targetPlayerIdTroya === currentRivalId) ? rivalHand : ownHand;
                    const cardToDiscardTroya = await chooseCardFromHand(targetHandTroya); // Elegir primera carta del rival

                    if (cardToDiscardTroya) {
                        const index = targetHandTroya.indexOf(cardToDiscardTroya);
                        if (index > -1) {
                            targetHandTroya.splice(index, 1);
                            pilaDescarte.push(cardToDiscardTroya);
                            const discardedCardTroya = cardDefinitions.find(c => c.id === cardToDiscardTroya);
                            gameMessageDiv.textContent = `${(targetPlayerIdTroya === currentUserId) ? ownNameDisplay.textContent : opponentNameDisplay.textContent} ha descartado ${discardedCardTroya.name}.`;
                            console.log("DEBUG: Caballo de Troya: Carta descartada:", discardedCardTroya.name);
                        }
                    }
                    if (isPlayer1 && targetPlayerIdTroya === currentRivalId) { rivalHand = targetHandTroya; } else if (targetPlayerIdTroya === currentUserId) { ownHand = targetHandTroya; }
                    break;

                case 'ranadelasuerte':
                    console.log("DEBUG: Efecto Rana de la Suerte activado.");
                    ownPos = Math.min(13, ownPos + 2);
                    gameMessageDiv.textContent += ' ¡Has avanzado 2 casillas!';
                    console.log("DEBUG: Rana de la Suerte: Nueva posición:", ownPos);
                    break;

                case 'perro':
                    console.log("DEBUG: Efecto Perro activado.");
                    // En un juego de 2 jugadores, si el siguiente jugador pierde su turno,
                    // el jugador actual efectivamente repite su turno.
                    effectsActivos.nextPlayerLosesTurn = true;
                    gameMessageDiv.textContent += ' El siguiente jugador perderá su turno.';
                    console.log("DEBUG: Perro: Efecto 'nextPlayerLosesTurn' activado. En 2 jugadores, esto significa que el jugador actual repetirá turno.");
                    break;

                case 'esclavo':
                    console.log("DEBUG: Efecto Esclavo activado.");
                    // Encuentra la carta con valor > 4 en la mano del jugador
                    const cardToRevealEsclavo = ownHand.find(cId => {
                        const cardDef = cardDefinitions.find(cd => cd.id === cId);
                        return cardDef && cardDef.value > 4;
                    });

                    if (cardToRevealEsclavo) {
                        ownPos = Math.min(13, ownPos + 1);
                        gameMessageDiv.textContent += ` ¡Has mostrado la carta ${cardDefinitions.find(c => c.id === cardToRevealEsclavo).name} y avanzado 1 casilla!`;
                        console.log("DEBUG: Esclavo: Avanza 1 casilla. Nueva posición:", ownPos);
                    } else {
                        gameMessageDiv.textContent += ' No tienes una carta mayor que 4 para mostrar.';
                        console.log("DEBUG: Esclavo: No hay carta para mostrar.");
                    }
                    break;

                case 'loco':
                    console.log("DEBUG: Efecto Loco activado.");
                    const targetPlayerIdLoco = await choosePlayer(); // Elegir rival
                    let targetHandLoco = (isPlayer1 && targetPlayerIdLoco === currentRivalId) ? rivalHand : ownHand;

                    if (ownHand.length === 0 || targetHandLoco.length === 0) {
                        gameMessageDiv.textContent = 'Uno de los jugadores no tiene cartas para el efecto Loco.';
                        console.log("DEBUG: Loco: Jugador sin cartas.");
                        break;
                    }

                    // Por simplicidad, se eligen las primeras cartas de cada mano
                    const ownCardLocoId = await chooseCardFromHand(ownHand);
                    const rivalCardLocoId = await chooseCardFromHand(targetHandLoco);

                    const ownCardLoco = cardDefinitions.find(c => c.id === ownCardLocoId);
                    const rivalCardLoco = cardDefinitions.find(c => c.id === rivalCardLocoId);

                    if (ownCardLoco && rivalCardLoco) {
                        // Remover las cartas de las manos y moverlas a la pila de descarte
                        ownHand.splice(ownHand.indexOf(ownCardLocoId), 1);
                        pilaDescarte.push(ownCardLocoId);
                        targetHandLoco.splice(targetHandLoco.indexOf(rivalCardLocoId), 1);
                        pilaDescarte.push(rivalCardLocoId);

                        gameMessageDiv.textContent = `Ambos mostráis: Tú ${ownCardLoco.name}, Rival ${rivalCardLoco.name}.`;
                        console.log("DEBUG: Loco: Cartas descartadas:", ownCardLoco.name, rivalCardLoco.name);

                        if (ownCardLoco.value > rivalCardLoco.value) {
                            ownPos = Math.min(13, ownPos + 2);
                            rivalPos = Math.max(0, rivalPos - 1);
                            gameMessageDiv.textContent += ` ¡Has ganado la comparación con Loco! Avanzas 2, el rival retrocede 1.`;
                            console.log("DEBUG: Loco: Gana propio. Posiciones:", ownPos, rivalPos);
                        } else if (rivalCardLoco.value > ownCardLoco.value) {
                            ownPos = Math.max(0, ownPos - 1);
                            rivalPos = Math.min(13, rivalPos + 2);
                            gameMessageDiv.textContent += ` ¡El rival ha ganado la comparación con Loco! Tú retrocedes 1, el rival avanza 2.`;
                            console.log("DEBUG: Loco: Gana rival. Posiciones:", ownPos, rivalPos);
                        } else {
                            gameMessageDiv.textContent += ` Empate en la comparación de Loco. Nadie avanza ni retrocede.`;
                            console.log("DEBUG: Loco: Empate.");
                        }
                    }
                    if (isPlayer1 && targetPlayerIdLoco === currentRivalId) { rivalHand = targetHandLoco; } else if (targetPlayerIdLoco === currentUserId) { ownHand = targetHandLoco; }
                    break;

                case 'vagabundo':
                    console.log("DEBUG: Efecto Vagabundo activado.");
                    const targetPlayerIdVagabundo = await choosePlayer(); // Elegir rival
                    const targetHandVagabundo = (isPlayer1 && targetPlayerIdVagabundo === currentRivalId) ? rivalHand : ownHand;

                    if (ownHand.length === 0 || targetHandVagabundo.length === 0) {
                        gameMessageDiv.textContent = 'Uno de los jugadores no tiene cartas para el efecto Vagabundo.';
                        console.log("DEBUG: Vagabundo: Jugador sin cartas.");
                        break;
                    }

                    const ownLowestCard = ownHand.reduce((minCard, cardId) => {
                        const card = cardDefinitions.find(c => c.id === cardId);
                        return (!minCard || (card && card.value < minCard.value)) ? card : minCard;
                    }, {value: Infinity}); // Initialize with a very high value

                    const rivalLowestCard = targetHandVagabundo.reduce((minCard, cardId) => {
                        const card = cardDefinitions.find(c => c.id === cardId);
                        return (!minCard || (card && card.value < minCard.value)) ? card : minCard;
                    }, {value: Infinity}); // Initialize with a very high value

                    if (ownLowestCard.value !== Infinity && rivalLowestCard.value !== Infinity) {
                        gameMessageDiv.textContent = `Comparando cartas más bajas: Tú ${ownLowestCard.name}, Rival ${rivalLowestCard.name}.`;
                        console.log("DEBUG: Vagabundo: Cartas más bajas - Propia:", ownLowestCard.name, "Rival:", rivalLowestCard.name);
                        if (ownLowestCard.value < rivalLowestCard.value) {
                            ownPos = Math.min(13, ownPos + 2);
                            gameMessageDiv.textContent += ` Tu carta más baja (${ownLowestCard.name}) es menor. Avanzas 2 casillas.`;
                            console.log("DEBUG: Vagabundo: Avanza 2 casillas. Nueva posición:", ownPos);
                        } else {
                            gameMessageDiv.textContent += ` Tu carta más baja (${ownLowestCard.name}) no es menor que la del rival.`;
                            console.log("DEBUG: Vagabundo: No avanza.");
                        }
                    } else {
                        gameMessageDiv.textContent = 'No se pudieron encontrar las cartas más bajas para la comparación.';
                        console.log("DEBUG: Vagabundo: No se pudieron encontrar las cartas más bajas.");
                    }
                    break;

                case 'filosofo':
                    console.log("DEBUG: Efecto Filósofo activado.");
                    const targetPlayerIdFilosofo = await choosePlayer(); // Elegir rival
                    let targetHandFilosofo = (isPlayer1 && targetPlayerIdFilosofo === currentRivalId) ? rivalHand : ownHand;

                    const ownDrawnCardId = drawCardForEffect();
                    const rivalDrawnCardId = drawCardForEffect();

                    if (!ownDrawnCardId || !rivalDrawnCardId) {
                        gameMessageDiv.textContent = 'No hay suficientes cartas en el mazo para el efecto Filósofo.';
                        // Devolver las cartas robadas al mazo si no se pueden completar las dos
                        if (ownDrawnCardId) mazo.push(ownDrawnCardId);
                        if (rivalDrawnCardId) mazo.push(rivalDrawnCardId);
                        console.log("DEBUG: Filósofo: Mazo insuficiente.");
                        break;
                    }

                    const ownDrawnCard = cardDefinitions.find(c => c.id === ownDrawnCardId);
                    const rivalDrawnCard = cardDefinitions.find(c => c.id === rivalDrawnCardId);

                    // Crear el contenido HTML para mostrar ambas cartas
                    const comparisonCardsDiv = document.createElement('div');
                    comparisonCardsDiv.classList.add('hand'); // Reutilizar estilos de mano
                    comparisonCardsDiv.style.justifyContent = 'space-around'; // Espaciar las cartas
                    comparisonCardsDiv.style.width = '100%';

                    const ownCardElement = createCardElement(ownDrawnCard);
                    const rivalCardElement = createCardElement(rivalDrawnCard);

                    comparisonCardsDiv.innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <span>Tu Carta:</span>
                            ${ownCardElement.outerHTML}
                        </div>
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <span>Carta del Rival:</span>
                            ${rivalCardElement.outerHTML}
                        </div>
                    `;

                    await showModal(
                        'Comparación de Cartas (Filósofo)',
                        comparisonCardsDiv,
                        [{ text: 'Cerrar', action: 'close' }]
                    );

                    gameMessageDiv.textContent = `Ambos robáis: Tú ${ownDrawnCard.name}, Rival ${rivalDrawnCard.name}.`;
                    console.log("DEBUG: Filósofo: Cartas robadas - Propia:", ownDrawnCard.name, "Rival:", rivalDrawnCard.name);

                    if (ownDrawnCard.value > rivalDrawnCard.value) {
                        ownHand.push(ownDrawnCardId);
                        pilaDescarte.push(rivalDrawnCardId);
                        gameMessageDiv.textContent += ` Tu carta es más alta, te la quedas y el rival descarta la suya.`;
                        console.log("DEBUG: Filósofo: Propia más alta.");
                    } else if (ownDrawnCard.value < rivalDrawnCard.value) {
                        pilaDescarte.push(ownDrawnCardId);
                        pilaDescarte.push(rivalDrawnCardId);
                        gameMessageDiv.textContent += ` Tu carta es más baja, ambos descartáis las cartas.`;
                        console.log("DEBUG: Filósofo: Rival más alta.");
                    } else {
                        pilaDescarte.push(ownDrawnCardId);
                        pilaDescarte.push(rivalDrawnCardId);
                        gameMessageDiv.textContent += ` Empate, ambos descartáis las cartas.`;
                        console.log("DEBUG: Filósofo: Empate.");
                    }
                    if (isPlayer1 && targetPlayerIdFilosofo === currentRivalId) { rivalHand = targetHandFilosofo; } else if (targetPlayerIdFilosofo === currentUserId) { ownHand = targetHandFilosofo; }
                    break;

                case 'nini':
                    console.log("DEBUG: Efecto Nini activado.");
                    const newCardNini = drawCardForEffect();
                    if (newCardNini) ownHand.push(newCardNini);
                    gameMessageDiv.textContent += ' Has robado 1 carta.';
                    console.log("DEBUG: Nini: Mano actualizada:", ownHand);
                    break;

                case 'influencer':
                    console.log("DEBUG: Efecto Influencer activado.");
                    const targetPlayerIdInfluencer = await choosePlayer(); // Elegir rival
                    const targetHandInfluencer = (isPlayer1 && targetPlayerIdInfluencer === currentRivalId) ? rivalHand : ownHand;

                    if (ownHand.length === 0 || targetHandInfluencer.length === 0) {
                        gameMessageDiv.textContent = 'Uno de los jugadores no tiene cartas para el efecto Influencer.';
                        console.log("DEBUG: Influencer: Jugador sin cartas.");
                        break;
                    }

                    const ownHighestCard = ownHand.reduce((maxCard, cardId) => {
                        const card = cardDefinitions.find(c => c.id === cardId);
                        return (!maxCard || (card && card.value > maxCard.value)) ? card : maxCard;
                    }, {value: -Infinity}); // Initialize with a very low value

                    const rivalHighestCard = targetHandInfluencer.reduce((maxCard, cardId) => {
                        const card = cardDefinitions.find(c => c.id === cardId);
                        return (!maxCard || (card && card.value > maxCard.value)) ? card : maxCard;
                    }, {value: -Infinity}); // Initialize with a very low value

                    if (ownHighestCard.value !== -Infinity && rivalHighestCard.value !== -Infinity) {
                        gameMessageDiv.textContent = `Comparando cartas más altas: Tú ${ownHighestCard.name}, Rival ${rivalHighestCard.name}.`;
                        console.log("DEBUG: Influencer: Cartas más altas - Propia:", ownHighestCard.name, "Rival:", rivalHighestCard.name);
                        if (ownHighestCard.value > rivalHighestCard.value) {
                            ownPos = Math.min(13, ownPos + 1);
                            rivalPos = Math.max(0, rivalPos - 1);
                            gameMessageDiv.textContent += ` ¡Tú ganas! Avanzas 1, rival retrocede 1.`;
                            console.log("DEBUG: Influencer: Gana propio. Posiciones:", ownPos, rivalPos);
                        } else if (rivalHighestCard.value > ownHighestCard.value) {
                            ownPos = Math.max(0, ownPos - 1);
                            rivalPos = Math.min(13, rivalPos + 1);
                            gameMessageDiv.textContent += ` ¡El rival gana! Tú retrocedes 1, rival avanza 1.`;
                            console.log("DEBUG: Influencer: Gana rival. Posiciones:", ownPos, rivalPos);
                        } else {
                            gameMessageDiv.textContent += ` Empate. Nadie avanza ni retrocede.`;
                            console.log("DEBUG: Influencer: Empate.");
                        }
                    } else {
                        gameMessageDiv.textContent = 'No se pudieron encontrar las cartas más altas para la comparación.';
                        console.log("DEBUG: Influencer: No se pudieron encontrar las cartas más altas.");
                    }
                    break;

                case 'camello':
                    console.log("DEBUG: Efecto Camello activado.");
                    const newCardCamello = drawCardForEffect();
                    if (newCardCamello) ownHand.push(newCardCamello);
                    gameMessageDiv.textContent = 'Has robado una carta. Ahora descarta una.';
                    if (ownHand.length > 0) {
                        // Por simplicidad, descarta la primera carta
                        const discardedCardCamelloId = ownHand.shift();
                        pilaDescarte.push(discardedCardCamelloId);
                        const discardedCardCamello = cardDefinitions.find(c => c.id === discardedCardCamelloId);
                        gameMessageDiv.textContent += ` Has descartado ${discardedCardCamello.name}.`;
                        console.log("DEBUG: Camello: Carta descartada:", discardedCardCamello.name);
                        if (discardedCardCamello && discardedCardCamello.value <= -1) { // Check if discardedCardCamello is not null
                            ownPos = Math.min(13, ownPos + 1);
                            gameMessageDiv.textContent += ' ¡Y avanzas 1 casilla!';
                            console.log("DEBUG: Camello: Avanza 1 casilla. Nueva posición:", ownPos);
                        }
                    } else {
                        gameMessageDiv.textContent += ' No tienes cartas para descartar.';
                        console.log("DEBUG: Camello: No hay cartas para descartar.");
                    }
                    break;

                case 'trabajador':
                    console.log("DEBUG: Efecto Trabajador activado.");
                    ownPos = Math.min(13, ownPos + 1);
                    gameMessageDiv.textContent += ' ¡Has avanzado 1 casilla!';
                    console.log("DEBUG: Trabajador: Nueva posición:", ownPos);
                    break;

                case 'artesano':
                    console.log("DEBUG: Efecto Artesano activado.");
                    if (ownPos >= 0 && ownPos <= 3) {
                        ownPos = Math.min(13, ownPos + 2);
                        gameMessageDiv.textContent += ' Avanzas 2 casillas.';
                    } else if (ownPos >= 4) {
                        ownPos = Math.min(13, ownPos + 1);
                        gameMessageDiv.textContent += ' Avanzas 1 casilla.';
                    }
                    console.log("DEBUG: Artesano: Nueva posición:", ownPos);
                    break;

                case 'policia':
                    console.log("DEBUG: Efecto Policía activado.");
                    const targetPlayerIdPolicia = await choosePlayer(); // Elegir rival
                    if (targetPlayerIdPolicia === currentUserId) {
                        ownPos = Math.max(0, ownPos - 1);
                        gameMessageDiv.textContent = 'Has retrocedido 1 casilla.';
                        console.log("DEBUG: Policía: Propio retrocede 1. Nueva posición:", ownPos);
                    } else {
                        rivalPos = Math.max(0, rivalPos - 1);
                        gameMessageDiv.textContent = `${opponentNameDisplay.textContent} retrocede 1 casilla.`;
                        console.log("DEBUG: Policía: Rival retrocede 1. Nueva posición:", rivalPos);
                    }
                    break;

                case 'detective':
                    console.log("DEBUG: Efecto Detective activado.");
                    const targetPlayerIdDetective = await choosePlayer(); // Elegir rival
                    const targetHandDetective = (isPlayer1 && targetPlayerIdDetective === currentRivalId) ? rivalHand : ownHand;
                    const cardToFindId = 'nini'; // Placeholder: debería ser elegida por el jugador que juega Detective
                    const cardToFind = cardDefinitions.find(c => c.id === cardToFindId);

                    if (targetHandDetective.includes(cardToFindId)) {
                        gameMessageDiv.textContent = `${(targetPlayerIdDetective === currentUserId) ? ownNameDisplay.textContent : opponentNameDisplay.textContent} tiene la carta ${cardToFind.name} y retrocede 2 casillas.`;
                        if (targetPlayerIdDetective === currentUserId) {
                            ownPos = Math.max(0, ownPos - 2);
                            console.log("DEBUG: Detective: Propio retrocede 2. Nueva posición:", ownPos);
                        } else {
                            rivalPos = Math.max(0, rivalPos - 2);
                            console.log("DEBUG: Detective: Rival retrocede 2. Nueva posición:", rivalPos);
                        }
                    } else {
                        gameMessageDiv.textContent = `${(targetPlayerIdDetective === currentUserId) ? ownNameDisplay.textContent : opponentNameDisplay.textContent} no tiene la carta ${cardToFind.name}.`;
                        console.log("DEBUG: Detective: Carta no encontrada.");
                    }
                    break;

                case 'guardaespaldas':
                    console.log("DEBUG: Efecto Guardaespaldas activado.");
                    effectsActivos[currentUserId] = { guardaespaldas: true, turnosRestantes: 1 };
                    gameMessageDiv.textContent = '¡Guardaespaldas activado! Estás protegido hasta tu próximo turno.';
                    console.log("DEBUG: Guardaespaldas: Efecto activado para el jugador actual.");
                    break;

                case 'abogado':
                    console.log("DEBUG: Efecto Abogado activado.");
                    const targetPlayerIdAbogado = await choosePlayer(); // Elegir rival
                    if (targetPlayerIdAbogado === currentUserId) {
                        gameMessageDiv.textContent = 'No puedes intercambiar cartas contigo mismo.';
                        console.log("DEBUG: Abogado: Intento de intercambio consigo mismo.");
                        break;
                    }
                    const tempHand = [...ownHand];
                    ownHand.length = 0;
                    ownHand.push(...rivalHand);
                    rivalHand.length = 0;
                    rivalHand.push(...tempHand);
                    gameMessageDiv.textContent = '¡Has intercambiado manos con el rival!';
                    console.log("DEBUG: Abogado: Manos intercambiadas.");
                    break;

                case 'banquero':
                    console.log("DEBUG: Efecto Banquero activado.");
                    if (lastPlayedCardId) {
                        const lastCard = cardDefinitions.find(c => c.id === lastPlayedCardId);
                        if (lastCard && lastCard.value >= 7) {
                            ownPos = Math.min(13, ownPos + 2);
                            gameMessageDiv.textContent = `La última carta (${lastCard.name}) es >= 7. Avanzas 2 casillas.`;
                            console.log("DEBUG: Banquero: Avanza 2 casillas. Nueva posición:", ownPos);
                        } else {
                            gameMessageDiv.textContent = `La última carta (${lastCard ? lastCard.name : 'ninguna'}) no es >= 7.`;
                            console.log("DEBUG: Banquero: No avanza.");
                        }
                    } else {
                        gameMessageDiv.textContent = 'No hay última carta jugada para Banquero.';
                        console.log("DEBUG: Banquero: No hay última carta.");
                    }
                    break;

                case 'musico':
                    console.log("DEBUG: Efecto Músico activado.");
                    for (let i = 0; i < 2; i++) {
                        const newCard = drawCardForEffect();
                        if (newCard) ownHand.push(newCard);
                    }
                    gameMessageDiv.textContent = 'Has robado 2 cartas. Ahora descarta 2.';
                    discardCards(ownHand, 2); // Discard 2 cards
                    console.log("DEBUG: Músico: Mano actualizada:", ownHand);
                    break;

                case 'arlequin':
                    console.log("DEBUG: Efecto Arlequín activado.");
                    for (let i = 0; i < 2; i++) {
                        const newCard = drawCardForEffect();
                        if (newCard) ownHand.push(newCard);
                    }
                    gameMessageDiv.textContent = 'Has robado 2 cartas. Ahora descarta 1.';
                    discardCards(ownHand, 1); // Discard 1 card
                    console.log("DEBUG: Arlequín: Mano actualizada:", ownHand);
                    break;

                case 'futbolista':
                    console.log("DEBUG: Efecto Futbolista activado.");
                    if (ownHand.length > 0) {
                        // Por simplicidad, descarta la primera carta
                        const discardedCardFutbolista = ownHand.shift();
                        pilaDescarte.push(discardedCardFutbolista);
                        ownPos = Math.min(13, ownPos + 2);
                        gameMessageDiv.textContent = 'Has descartado una carta y avanzado 2 casillas.';
                        console.log("DEBUG: Futbolista: Avanza 2 casillas. Nueva posición:", ownPos);
                    } else {
                        gameMessageDiv.textContent = 'No tienes cartas para descartar y usar Futbolista.';
                        console.log("DEBUG: Futbolista: No hay cartas para descartar.");
                    }
                    break;

                case 'capo':
                    console.log("DEBUG: Efecto Capo activado.");
                    ownPos = Math.min(13, ownPos + 1);
                    const targetPlayerIdCapo = await choosePlayer(); // Elegir rival
                    if (targetPlayerIdCapo === currentUserId) {
                        ownPos = Math.max(0, ownPos - 1);
                        gameMessageDiv.textContent = 'Avanzas 1, pero luego retrocedes 1 (te elegiste a ti mismo).';
                        console.log("DEBUG: Capo: Propio avanza y retrocede. Nueva posición:", ownPos);
                    } else {
                        rivalPos = Math.max(0, rivalPos - 1);
                        gameMessageDiv.textContent = `Avanzas 1 casilla. ${opponentNameDisplay.textContent} retrocede 1 casilla.`;
                        console.log("DEBUG: Capo: Rival retrocede 1. Nueva posición:", rivalPos);
                    }
                    break;

                case 'politico':
                    console.log("DEBUG: Efecto Político activado.");
                    ownPos = Math.min(13, ownPos + 1); // Avanza 1 casilla siempre

                    const playerChoiceDiv = document.createElement('div');
                    playerChoiceDiv.innerHTML = `
                        <p>¿A quién quieres aplicar el efecto de descartar y robar cartas?</p>
                    `;

                    const chosenPlayerIdPolitico = await showModal(
                        'Efecto Político: Elegir Jugador',
                        playerChoiceDiv,
                        [
                            { text: 'A mí', action: currentUserId },
                            { text: 'Al Rival', action: currentRivalId }
                        ]
                    );

                    let targetHandPolitico;
                    let targetPlayerNamePolitico;

                    if (chosenPlayerIdPolitico === currentUserId) {
                        targetHandPolitico = ownHand;
                        targetPlayerNamePolitico = ownNameDisplay.textContent;
                    } else {
                        targetHandPolitico = rivalHand;
                        targetPlayerNamePolitico = opponentNameDisplay.textContent;
                    }

                    const numCardsToRedraw = targetHandPolitico.length;

                    discardCards(targetHandPolitico, numCardsToRedraw); // Discard all cards
                    targetHandPolitico.length = 0; // Ensure hand is empty after discarding
                    for (let i = 0; i < numCardsToRedraw; i++) {
                        const newCard = drawCardForEffect();
                        if (newCard) targetHandPolitico.push(newCard);
                    }
                    
                    gameMessageDiv.textContent = `Avanzas 1 casilla. ${targetPlayerNamePolitico} ha descartado y robado cartas.`;
                    console.log("DEBUG: Político: Cartas descartadas/robadas. Propio avanza 1.");
                    
                    // Asegurarse de que las manos se actualicen correctamente en el estado
                    if (chosenPlayerIdPolitico === currentUserId) {
                        ownHand = targetHandPolitico;
                    } else {
                        rivalHand = targetHandPolitico;
                    }
                    break;

                case 'sectario':
                    console.log("DEBUG: Efecto Sectario activado.");
                    const targetPlayerIdSectario = await choosePlayer(); // Elegir rival
                    let targetHandSectario = (isPlayer1 && targetPlayerIdSectario === currentRivalId) ? rivalHand : ownHand;

                    // Crear el contenido HTML para mostrar las cartas del rival
                    const rivalHandDisplayDivSectario = document.createElement('div');
                    rivalHandDisplayDivSectario.classList.add('hand'); // Reutilizar estilos de mano
                    if (targetHandSectario.length > 0) {
                        targetHandSectario.forEach(cardId => {
                            const card = cardDefinitions.find(c => c.id === cardId);
                            if (card) {
                                rivalHandDisplayDivSectario.appendChild(createCardElement(card));
                            }
                        });
                    } else {
                        rivalHandDisplayDivSectario.textContent = 'El rival no tiene cartas en la mano.';
                    }

                    const exchangeDecision = await showModal(
                        'Cartas del Rival (Sectario)',
                        rivalHandDisplayDivSectario,
                        [
                            { text: 'Intercambiar Cartas', action: 'exchange' },
                            { text: 'No Intercambiar', action: 'no_exchange' }
                        ]
                    );

                    if (exchangeDecision === 'exchange') {
                        if (targetPlayerIdSectario !== currentUserId) { // Asegurarse de no intercambiar consigo mismo
                            const tempHand = [...ownHand];
                            ownHand.length = 0;
                            ownHand.push(...targetHandSectario);
                            targetHandSectario.length = 0;
                            targetHandSectario.push(...tempHand);
                            gameMessageDiv.textContent = '¡Has intercambiado manos!';
                            console.log("DEBUG: Sectario: Manos intercambiadas.");
                        } else {
                            gameMessageDiv.textContent = 'No puedes intercambiar contigo mismo.';
                            console.log("DEBUG: Sectario: Intento de intercambio consigo mismo.");
                        }
                    } else {
                        gameMessageDiv.textContent = 'Has decidido no intercambiar cartas.';
                        console.log("DEBUG: Sectario: No se intercambiaron cartas.");
                    }

                    ownPos = Math.min(13, ownPos + 1);
                    if (isPlayer1 && targetPlayerIdSectario === currentRivalId) { rivalHand = targetHandSectario; } else if (targetPlayerIdSectario === currentUserId) { ownHand = targetHandSectario; }
                    break;

                case 'astronauta':
                    console.log("DEBUG: Efecto Astronauta activado.");
                    ownPos = Math.min(13, ownPos + 1);
                    if (ownPos >= 8) {
                        const newCard = drawCardForEffect();
                        if (newCard) ownHand.push(newCard);
                        gameMessageDiv.textContent += ' ¡Y has robado 1 carta!';
                        console.log("DEBUG: Astronauta: Roba 1 carta.");
                    }
                    console.log("DEBUG: Astronauta: Nueva posición:", ownPos);
                    break;

                case 'arcangel':
                    console.log("DEBUG: Efecto Arcángel activado.");
                    ownPos = Math.min(13, ownPos + 1);
                    for (let i = 0; i < 3; i++) {
                        const newCard = drawCardForEffect();
                        if (newCard) ownHand.push(newCard);
                    }
                    gameMessageDiv.textContent = 'Avanzas 1 casilla y robas 3 cartas. Ahora descarta 2.';
                    discardCards(ownHand, 2); // Discard 2 cards
                    console.log("DEBUG: Arcángel: Mano actualizada:", ownHand);
                    break;

                case 'semidios':
                    console.log("DEBUG: Efecto Semidiós activado.");
                    ownPos = Math.min(13, ownPos + 1);
                    gameMessageDiv.textContent += ' Avanzas 1 casilla y repites tu turno.';
                    console.log("DEBUG: Semidiós: Repite turno. Nueva posición:", ownPos);
                    break;

                case 'ojotodove':
                    console.log("DEBUG: Efecto Ojo que todo lo ve activado.");
                    ownPos = Math.min(13, ownPos + 1);

                    // Crear el contenido HTML para mostrar las cartas del rival
                    const rivalHandDisplayDivOjo = document.createElement('div');
                    rivalHandDisplayDivOjo.classList.add('hand'); // Reutilizar estilos de mano
                    if (rivalHand.length > 0) {
                        rivalHand.forEach(cardId => {
                            const card = cardDefinitions.find(c => c.id === cardId);
                            if (card) {
                                rivalHandDisplayDivOjo.appendChild(createCardElement(card));
                            }
                        });
                    } else {
                        rivalHandDisplayDivOjo.textContent = 'El rival no tiene cartas en la mano.';
                    }

                    await showModal(
                        'Cartas del Rival (Ojo que todo lo ve)',
                        rivalHandDisplayDivOjo,
                        [{ text: 'Cerrar', action: 'close' }]
                    );

                    gameMessageDiv.textContent = `Avanzas 1 casilla. Has visto las cartas del rival.`;
                    console.log("DEBUG: Ojo que todo lo ve: Cartas del rival mostradas.");
                    break;

                default:
                    console.warn('DEBUG: Efecto de carta no implementado:', card.name);
                    gameMessageDiv.textContent = `Has jugado ${card.name}.`;
                    break;
            }

            // Asegurarse de que los cambios en las manos y posiciones se reflejen en el objeto de estado
            // Asignar de nuevo las variables locales modificadas al objeto 'state' que se pasó por referencia
            state.ownHand = ownHand;
            state.rivalHand = rivalHand;
            state.ownPos = ownPos;
            state.rivalPos = rivalPos;
            state.mazo = mazo;
            state.pilaDescarte = pilaDescarte;
            state.effectsActivos = effectsActivos; // Update effects in state

            console.log("DEBUG: applyCardEffect - Estado final del efecto:", { ownHand: [...ownHand], rivalHand: [...rivalHand], ownPos, rivalPos, mazo: [...mazo], pilaDescarte: [...pilaDescarte], effectsActivos: {...effectsActivos} });
        }


        // Función para pasar el turno
        async function passTurn() {
            const roomRef = db.collection('SALAS').doc(currentRoomId);
            const roomDoc = await roomRef.get();
            const roomData = roomDoc.data();
            const gameState = roomData.estadoJuego;

            if (gameState.turnoActual !== currentUserId) {
                gameMessageDiv.textContent = '¡No es tu turno para pasar!';
                return;
            }
            console.log("DEBUG: Pasando turno...");

            // Manejar efecto "Perro" si está activo para el siguiente jugador
            let nextTurnPlayerId = currentRivalId; // Por defecto, el turno pasa al rival
            const updatedEffects = { ...gameState.efectosActivos };

            if (updatedEffects && updatedEffects.nextPlayerLosesTurn) {
                gameMessageDiv.textContent = `${opponentNameDisplay.textContent} pierde su turno por el efecto Perro. ¡Es tu turno de nuevo!`;
                delete updatedEffects.nextPlayerLosesTurn;
                nextTurnPlayerId = currentUserId; // El turno se queda en el mismo jugador
                console.log("DEBUG: Perro: Rival pierde turno, propio repite.");
            } else {
                gameMessageDiv.textContent = `Has pasado el turno. Turno de ${opponentNameDisplay.textContent}.`;
                console.log("DEBUG: Turno pasado al rival.");
            }

            // Reducir duración de efectos temporales (ej. Guardaespaldas)
            if (updatedEffects[currentUserId] && updatedEffects[currentUserId].guardaespaldas) {
                updatedEffects[currentUserId].turnosRestantes--;
                if (updatedEffects[currentUserId].turnosRestantes <= 0) {
                    delete updatedEffects[currentUserId];
                    gameMessageDiv.textContent += ' El efecto Guardaespaldas ha terminado.';
                    console.log("DEBUG: Guardaespaldas: Efecto terminado.");
                }
            }

            // Resetear el estado de robo para el siguiente jugador (o para el mismo si repite turno)
            const newDrawStatus = { ...gameState.drawStatus };
            newDrawStatus[nextTurnPlayerId] = false; // El siguiente jugador podrá robar
            console.log("DEBUG: Estado de robo reseteado para:", nextTurnPlayerId, "a false. newDrawStatus:", newDrawStatus);

            const updatePayload = {
                'estadoJuego.turnoActual': nextTurnPlayerId,
                'estadoJuego.efectosActivos': updatedEffects,
                'estadoJuego.drawStatus': newDrawStatus
            };
            console.log("DEBUG: Payload de actualización de turno:", updatePayload);
            await roomRef.update(updatePayload);
        }

        // --- Event Listeners ---

        // Lógica para la Pantalla 1: Introducir Nombre de Jugador
        btnEnterName.addEventListener('click', async () => {
            const name = playerNameInput.value.trim();
            const rival = rivalNameInputScreen1.value.trim();

            nameError.textContent = '';
            rivalErrorScreen1.textContent = '';

            let valid = true;
            if (!name) {
                nameError.textContent = 'Por favor, introduce tu nombre.';
                valid = false;
            }

            if (!rival) {
                rivalErrorScreen1.textContent = 'Por favor, introduce el nombre de tu rival.';
                valid = false;
            } else if (name && rival === name) {
                rivalErrorScreen1.textContent = 'No puedes ser tu propio rival. Introduce un nombre diferente.';
                valid = false;
            }

            if (valid) {
                currentPlayerName = name;
                rivalPlayerName = rival;
                console.log(`Tu nombre: ${currentPlayerName}, Nombre del rival: ${rivalPlayerName}`);

                await signInAnonymouslyAndGetUid();
                if (currentUserId) {
                    await findOrCreateRoom(currentPlayerName, rivalPlayerName);
                    // showScreen(screen3) es manejado por findOrCreateRoom o listenToRoomChanges
                } else {
                    nameError.textContent = 'Error de autenticación. Por favor, recarga la página.';
                }
            }
        });


        btnPassTurn.addEventListener('click', passTurn);

        // Inicialmente, mostrar la primera pantalla
        showScreen(screen1);

        // Ajustar el tablero cuando la ventana cambia de tamaño
        window.addEventListener('resize', () => {
            if (screen3.classList.contains('active')) {
                // Solo renderizar si la pantalla de juego está activa
                // Necesitamos los valores actuales de posición para re-renderizar
                // Esto requerirá que el estado del juego sea accesible globalmente o se pase
                // Por ahora, solo se re-renderiza con valores por defecto si no hay estado
                // Esta llamada debería idealmente usar el estado actual del juego
                // Para simplificar, asumimos que el updateGameUI se encargará de esto con el onSnapshot
            }
        });

        // Asegurarse de que el tablero se renderice correctamente al cargar la pantalla 3
        // Esto se ejecutará una vez que la pantalla 3 sea activa
        const observer = new MutationObserver((mutationsList, observer) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (screen3.classList.contains('active')) {
                        // Dar un pequeño retraso para asegurar que el DOM esté listo y los tamaños calculados
                        // Se llama a renderGameBoard con 0,0 aquí, pero el onSnapshot lo actualizará con los valores reales
                        setTimeout(() => {
                            // Si ya hay un roomData disponible, usarlo. Si no, 0,0 es un buen inicio.
                            if (currentRoomId) {
                                db.collection('SALAS').doc(currentRoomId).get().then(doc => {
                                    if (doc.exists) {
                                        const roomData = doc.data();
                                        const ownPos = roomData.jugador1Id === currentUserId ? roomData.estadoJuego.posicionJugador1 : roomData.estadoJuego.posicionJugador2;
                                        const opponentPos = roomData.jugador1Id === currentUserId ? roomData.estadoJuego.posicionJugador2 : roomData.estadoJuego.posicionJugador1;
                                        renderGameBoard(ownPos, opponentPos);
                                    } else {
                                        renderGameBoard(0, 0);
                                    }
                                }).catch(error => {
                                    console.error("Error al obtener datos de la sala para renderizar tablero:", error);
                                    renderGameBoard(0, 0);
                                });
                            } else {
                                renderGameBoard(0, 0);
                            }
                        }, 100);
                    }
                }
            }
        });
        observer.observe(screen3, { attributes: true });

    </script>
</body>
</html>
