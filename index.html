<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Cartas - CS</title>
    <style>
        /* Estilos CSS embebidos */
        body {
            font-family: 'Inter', sans-serif; /* Usamos Inter como se sugiere */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1a1a; /* Fondo casi negro para elegancia */
            color: #ffffff; /* Texto blanco puro */
            overflow-x: hidden; /* Evita el scroll horizontal */
            box-sizing: border-box; /* Incluye padding y border en el tamaño total del elemento */
            padding: 1rem; /* Pequeño padding general para que el contenido no toque los bordes */
        }

        .game-screen {
            display: none; /* Ocultar todas las pantallas por defecto */
            flex-direction: column;
            align-items: center;
            padding: 1.5rem; /* Más padding para un look más espacioso */
            border: 1px solid #FF0000; /* Borde fino rojo */
            border-radius: 0; /* Bordes rectos */
            background-color: #222222; /* Fondo gris muy oscuro */
            box-shadow: 0 0.125rem 0.625rem rgba(0, 0, 0, 0.5); /* Sombra más sutil */
            width: 100%; /* Ocupa el ancho completo */
            max-width: 75rem; /* Ancho máximo para pantallas grandes (1200px) */
            box-sizing: border-box;
            gap: 1.25rem; /* Más espacio entre elementos (20px) */
        }

        .game-screen.active {
            display: flex; /* Mostrar la pantalla activa */
        }

        h1 {
            color: #FF0000; /* Título rojo */
            margin-bottom: 1.5rem; /* Más margen */
            text-align: center;
            font-size: 2.2rem; /* Título más grande */
            text-transform: uppercase; /* Mayúsculas para un look más limpio */
            letter-spacing: 0.125rem; /* Espaciado entre letras */
        }

        .input-group {
            margin-bottom: 1.25rem; /* Más margen */
            width: 100%;
            text-align: center;
        }

        label {
            display: block;
            margin-bottom: 0.625rem; /* Más margen */
            font-size: 1.15rem; /* Texto de label más grande */
            color: #cccccc; /* Gris suave para labels */
        }

        input[type="text"] {
            padding: 0.9375rem; /* Más padding */
            width: calc(100% - 1.875rem); /* Ajuste para padding */
            border: 1px solid #555555; /* Borde de input gris oscuro */
            border-radius: 0; /* Bordes rectos */
            background-color: #333333; /* Fondo de input más oscuro */
            color: #ffffff; /* Texto blanco */
            font-size: 1.1rem; /* Fuente de input más grande */
            margin-bottom: 0.9375rem; /* Más margen */
            box-sizing: border-box;
        }

        button {
            padding: 0.875rem 1.875rem; /* Más padding */
            background-color: #FF0000; /* Botón rojo */
            color: #ffffff; /* Texto blanco */
            border: none;
            border-radius: 0; /* Bordes rectos */
            cursor: pointer;
            font-size: 1.1rem; /* Fuente de botón más grande */
            font-weight: bold;
            text-transform: uppercase; /* Mayúsculas */
            letter-spacing: 0.0625rem; /* Espaciado entre letras */
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 0.1875rem 0.5rem rgba(0, 0, 0, 0.4); /* Sombra sutil */
        }

        button:hover {
            background-color: #CC0000; /* Rojo más oscuro al pasar el ratón */
            transform: translateY(-0.0625rem); /* Menos movimiento */
            box-shadow: 0 0.3125rem 0.75rem rgba(0, 0, 0, 0.5);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 0.125rem 0.375rem rgba(0, 0, 0, 0.4);
        }

        .error-message {
            color: #ff4d4d; /* Rojo de error ligeramente más brillante */
            margin-top: 0.625rem;
            font-weight: bold;
            text-align: center;
            font-size: 1rem;
        }

        /* Estilos para la pantalla de juego (screen3) */
        #screen3 {
            width: 100%;
            max-width: 75rem; /* 1200px */
            height: 95vh;
            display: grid;
            grid-template-rows: 1fr 2fr 1fr;
            gap: 1.25rem; /* Más espacio entre secciones (20px) */
            padding: 0.9375rem; /* 15px */
            background-color: #1a1a1a; /* Fondo que coincide con el body */
            border: none;
            box-shadow: none;
        }

        .player-area {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0.9375rem; /* 15px */
            border: 1px solid #333333; /* Borde muy sutil */
            border-radius: 0; /* Bordes rectos */
            background-color: #2b2b2b; /* Fondo gris oscuro */
            box-shadow: inset 0 0 0.1875rem rgba(0, 0, 0, 0.2); /* Sombra interior muy sutil */
        }

        .opponent-area {
            order: 1;
            flex-direction: column;
            position: relative;
        }

        .own-area {
            order: 3;
            flex-direction: column;
            position: relative;
        }

        /* Nuevo estilo para el tablero lineal */
        .board-area {
            order: 2;
            display: flex; /* Usar flexbox para la línea de casillas */
            justify-content: space-between; /* Espacio entre casillas */
            align-items: center;
            background-color: #1a1a1a;
            border: 1px solid #FF0000;
            border-radius: 0;
            position: relative;
            width: 100%;
            max-width: 56.25rem; /* Ancho máximo para el tablero lineal (900px) */
            height: 5rem; /* Altura fija para la línea (80px) */
            margin: auto;
            box-shadow: 0 0 0.625rem rgba(255, 0, 0, 0.3);
            padding: 0 0.625rem; /* Pequeño padding horizontal (10px) */
        }

        /* Estilos para las manos y los mazos/descartes */
        .hand {
            display: flex;
            gap: 0.9375rem; /* Más espacio entre cartas (15px) */
            min-height: 12.5rem; /* Espacio para cartas más grandes (200px) */
            border: none; /* Sin borde */
            padding: 0.625rem;
            border-radius: 0;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .deck-discard-area {
            display: flex;
            gap: 2.5rem; /* Más espacio (40px) */
            margin-top: 1.25rem;
            justify-content: center;
            align-items: center;
        }

        .deck, .discard-pile {
            width: 8.75rem; /* Cartas más grandes (140px) */
            height: 12.5rem; /* Cartas más grandes (200px) */
            border: 1px solid #555555; /* Borde sutil */
            background-color: #333333; /* Fondo oscuro */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem; /* Texto más grande */
            color: #cccccc;
            border-radius: 0; /* Bordes rectos */
            box-shadow: 0 0.125rem 0.375rem rgba(0, 0, 0, 0.3);
            cursor: pointer;
        }

        /* Estilo para el envés de la carta del rival */
        .opponent-hand .card-back {
            background-color: #000000; /* Negro sólido */
            color: #ffffff;
            width: 8.125rem; /* Ligeramente más pequeña que la propia (130px) */
            height: 11.875rem; /* 190px */
            border-radius: 0; /* Bordes rectos */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem; /* Letras CS más grandes */
            font-weight: bold;
            border: 1px solid #444444; /* Borde sutil */
            box-shadow: 0 0.125rem 0.375rem rgba(0, 0, 0, 0.3);
        }

        /* Estilos para la carta en mano del jugador */
        .card-in-hand {
            width: 12.5rem; /* Tamaño base de la carta (200px) */
            height: 18.75rem; /* 300px */
            background-color: #333; /* Fondo oscuro para la carta */
            border: 2px solid #FF0000;
            border-radius: 0.5rem; /* Bordes ligeramente redondeados para las cartas (8px) */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem; /* Más padding interno (12px) */
            box-shadow: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.5);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            overflow: hidden; /* Asegura que nada se salga de la carta */
            box-sizing: border-box;
            position: relative; /* Para la posición del texto absoluto si es necesario */
        }

        .card-in-hand:hover {
            transform: translateY(-0.5rem) scale(1.05); /* Efecto de elevación y escala al pasar el ratón */
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.7);
        }

        .card-title {
            font-size: 1.3rem; /* Ajustado */
            color: #ffffff;
            margin-bottom: 0.5rem;
            text-align: center;
            font-weight: bold;
        }

        .card-image-container {
            width: 100%; /* Ocupa el ancho completo del padding de la carta */
            height: 7.5rem; /* Altura fija para la imagen (120px) */
            overflow: hidden; /* Oculta partes de la imagen que se desborden */
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #FF0000; /* Borde para la imagen */
            border-radius: 0.25rem; /* Bordes redondeados para la imagen (4px) */
            margin-bottom: 0.5rem;
            box-sizing: border-box;
        }

        .card-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Asegura que la imagen cubra el contenedor sin distorsionarse */
            aspect-ratio: 1/1; /* Fuerza la relación de aspecto cuadrada */
            border-radius: 0.25rem; /* Bordes redondeados para la imagen */
        }

        .card-text {
            font-size: 0.9rem; /* Ajustado */
            color: #cccccc;
            text-align: center;
            flex-grow: 1; /* Permite que el texto ocupe el espacio disponible */
            overflow: hidden; /* Oculta el texto que se desborda */
            text-overflow: ellipsis; /* Añade puntos suspensivos al final */
            display: -webkit-box; /* Para truncar en múltiples líneas */
            -webkit-line-clamp: 3; /* Muestra solo 3 líneas inicialmente */
            -webkit-box-orient: vertical;
            transition: all 0.3s ease-out; /* Transición suave para la expansión */
            margin-bottom: 0.3125rem; /* 5px */
            line-height: 1.3; /* Espaciado entre líneas */
        }

        /* Estilo para cuando el texto se expande */
        .card-text:hover,
        .card-text.expanded {
            -webkit-line-clamp: unset; /* Muestra todas las líneas */
            overflow: visible; /* Permite que el texto se desborde verticalmente */
            height: auto; /* La altura se ajusta al contenido */
            white-space: normal; /* Permite el salto de línea normal */
            background-color: rgba(0, 0, 0, 0.8); /* Fondo para el texto expandido */
            padding: 0.3125rem; /* 5px */
            border-radius: 0.25rem; /* 4px */
            position: absolute; /* Posición absoluta para no afectar el layout de la carta */
            top: 50%; /* Centrar verticalmente */
            left: 50%; /* Centrar horizontalmente */
            transform: translate(-50%, -50%); /* Ajuste para centrar */
            width: 90%; /* Ocupa casi todo el ancho de la carta */
            z-index: 10; /* Asegura que esté por encima de otros elementos */
            box-shadow: 0 0 0.9375rem rgba(0, 0, 0, 0.9); /* Sombra más pronunciada */
            max-height: 80%; /* Limita la altura máxima para que no se salga de la pantalla */
            overflow-y: auto; /* Permite scroll si el texto es muy largo */
        }

        .card-stats {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-top: 0.3125rem; /* 5px */
            font-size: 1rem;
            color: #ffffff;
            font-weight: bold;
        }

        .card-stat {
            background-color: #444;
            padding: 0.1875rem 0.5rem; /* 3px 8px */
            border-radius: 0.25rem; /* 4px */
            border: 1px solid #FF0000;
        }

        /* Posicionamiento de los nombres de jugador */
        #ownNameDisplay, #opponentNameDisplay {
            font-size: 1.5rem; /* Nombres más grandes */
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 0.9375rem; /* Más margen (15px) */
            text-transform: uppercase;
            letter-spacing: 0.0625rem; /* 1px */
        }

        /* Contenedor para efectos activos */
        .active-effects-container {
            position: absolute;
            top: 0.625rem; /* 10px */
            right: 0.625rem; /* 10px */
            display: flex;
            flex-direction: column;
            gap: 0.3125rem; /* 5px */
            align-items: flex-end;
            z-index: 50;
        }

        .active-effect-card {
            display: flex;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #FFD700;
            border-radius: 0.3125rem; /* 5px */
            padding: 0.3125rem 0.625rem; /* 5px 10px */
            color: #FFD700;
            font-size: 0.9rem;
            gap: 0.625rem; /* 10px */
        }

        .active-effect-card .card-image-small {
            width: 2.5rem; /* 40px */
            height: 2.5rem; /* 40px */
            border-radius: 0.1875rem; /* 3px */
            background-size: cover;
            background-position: center;
            border: 1px solid #FFD700;
        }

        /* Botón de pasar turno */
        .game-button {
            margin-top: 1.5625rem; /* 25px */
            align-self: center;
        }

        .game-message {
            text-align: center;
            font-size: 1.3rem; /* Mensajes más grandes */
            font-weight: bold;
            margin-top: 1.25rem; /* 20px */
            color: #FFD700; /* Amarillo dorado para mensajes de juego, contrasta bien */
            text-shadow: 0 0 0.3125rem rgba(255, 215, 0, 0.3); /* Sombra sutil para el mensaje */
        }

        /* Estilos para las casillas del tablero lineal */
        .board-cell {
            width: 3.4375rem; /* Ancho de cada casilla (55px) */
            height: 3.4375rem; /* Altura de cada casilla (55px) */
            background-color: #333333;
            border: 1px solid #555555;
            border-radius: 0; /* Cuadradas */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.1rem; /* Texto más grande */
            font-weight: bold;
            color: #ffffff;
            box-shadow: inset 0 0 0.25rem rgba(0, 0, 0, 0.3);
            position: relative; /* Para posicionar los tokens dentro */
        }

        /* Estilos para los jugadores en el tablero */
        .player-token {
            position: absolute;
            width: 2.1875rem; /* 35px */
            height: 2.1875rem; /* 35px */
            border-radius: 0; /* Cuadrados */
            border: 2px solid #ffffff;
            box-shadow: 0 0 0.375rem rgba(0, 0, 0, 0.6);
            z-index: 10;
            top: 50%; /* Centrar verticalmente */
            transform: translateY(-50%);
        }

        .player1-token {
            background-color: #e74c3c; /* Rojo */
            left: 0.3125rem; /* Pequeño offset para P1 (5px) */
        }

        .player2-token {
            background-color: #3498db; /* Azul */
            right: 0.3125rem; /* Pequeño offset para P2 (5px) */
        }

        /* Opciones al clicar una carta */
        .card-options {
            position: absolute;
            background-color: #2b2b2b; /* Fondo oscuro */
            border: 1px solid #FF0000; /* Borde rojo */
            border-radius: 0; /* Bordes rectos */
            padding: 0.75rem; /* Más padding (12px) */
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 0.5rem; /* Más espacio (8px) */
            box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.4);
        }

        .card-options button {
            width: 100%;
            padding: 0.625rem 1.125rem; /* Más padding (10px 18px) */
            font-size: 1rem; /* Fuente más grande */
            background-color: #FF0000;
            color: #ffffff;
            text-transform: uppercase;
        }

        /* Estilos para el modal y el overlay */
        .modal-overlay {
            display: none; /* Oculto por defecto */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Fondo oscuro semitransparente */
            backdrop-filter: blur(0.3125rem); /* Efecto de desenfoque (5px) */
            z-index: 1000; /* Por encima de todo */
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #222222; /* Fondo gris oscuro */
            border: 1px solid #FF0000; /* Borde rojo */
            border-radius: 0; /* Bordes rectos */
            padding: 1.875rem; /* 30px */
            box-shadow: 0 0.3125rem 0.9375rem rgba(0, 0, 0, 0.6);
            text-align: center;
            max-width: 90%;
            width: 37.5rem; /* Ancho fijo para el modal (600px) */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 1.25rem; /* 20px */
        }

        /* Estilo específico para el modal de descarte */
        .modal-content.discard-modal-content {
            border: 2px solid #800080; /* Purple border */
            outline: 2px solid white; /* White outline */
            outline-offset: -0.25rem; /* To make it appear as a nested border (4px) */
        }

        .modal-content h2 {
            color: #FF0000;
            margin-bottom: 0.9375rem; /* 15px */
            font-size: 1.8rem;
        }

        .modal-body {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.9375rem; /* 15px */
            margin-bottom: 1.25rem; /* 20px */
            max-height: 25rem; /* Altura máxima para el scroll (400px) */
            overflow-y: auto; /* Scroll si el contenido es demasiado grande */
            padding-right: 0.625rem; /* Espacio para la barra de scroll (10px) */
        }

        .modal-body .card-in-hand {
            /* Reutilizar estilos de carta, pero ajustarlos para el modal si es necesario */
            width: 7.5rem; /* Un poco más pequeñas en el modal (120px) */
            height: 10.625rem; /* 170px */
            cursor: default; /* No clicables en el modal de visualización */
            transform: none; /* Eliminar hover effects */
            box-shadow: 0 0.125rem 0.5rem rgba(0,0,0,0.3);
        }

        .modal-body .card-in-hand.selectable {
            cursor: pointer;
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        .modal-body .card-in-hand.selectable:hover {
            transform: translateY(-0.3125rem) scale(1.05); /* 5px */
            box-shadow: 0 0.3125rem 0.9375rem rgba(0,0,0,0.4);
        }

        .modal-body .card-in-hand.selected {
            border: 3px solid white; /* White border for selected */
            box-shadow: 0 0 0.9375rem white; /* Glow for selected */
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1.25rem; /* 20px */
        }

        .modal-buttons button {
            padding: 0.75rem 1.5625rem; /* 12px 25px */
            font-size: 1rem;
            background-color: #FF0000;
            color: #ffffff;
            border: none;
            border-radius: 0;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .modal-buttons button:hover {
            background-color: #CC0000;
        }


        /* Media Queries para responsividad */
        @media (max-width: 48rem) { /* 768px */
            .game-screen {
                padding: 0.9375rem; /* 15px */
                max-width: 95%;
            }

            h1 {
                font-size: 1.6rem;
                margin-bottom: 0.9375rem; /* 15px */
            }

            label {
                font-size: 1rem;
            }

            input[type="text"], button {
                padding: 0.625rem; /* 10px */
                font-size: 0.9rem;
            }

            #screen3 {
                grid-template-rows: auto 1fr auto;
                height: auto;
                min-height: 95vh;
                padding: 0.625rem; /* 10px */
                gap: 0.625rem; /* 10px */
            }

            .player-area, .deck-discard-area {
                flex-direction: column;
                gap: 0.5rem; /* 8px */
                padding: 0.5rem; /* 8px */
            }

            .hand {
                min-height: 10rem; /* 160px */
                gap: 0.625rem; /* 10px */
            }

            .card-in-hand {
                width: 9.375rem; /* 150px */
                height: 14.375rem; /* 230px */
                padding: 0.5rem; /* 8px */
            }

            .card-title {
                font-size: 1.1rem;
            }

            .card-image-container {
                height: 6.25rem; /* 100px */
            }

            .card-text {
                font-size: 0.8rem;
                -webkit-line-clamp: 4; /* Mostrar más líneas por defecto en móvil si hay espacio */
            }

            .card-text:hover,
            .card-text.expanded {
                font-size: 0.9rem; /* Ajuste de fuente al expandir */
                width: 95%; /* Ocupa más ancho en móvil */
            }

            .board-cell {
                width: 2.5rem; /* 40px */
                height: 2.5rem; /* 40px */
                font-size: 0.8rem;
            }
            .player-token {
                width: 1.75rem; /* 28px */
                height: 1.75rem; /* 28px */
            }
            #ownNameDisplay, #opponentNameDisplay {
                font-size: 1.2rem;
                margin-bottom: 0.5rem; /* 8px */
            }
            .game-button {
                margin-top: 0.9375rem; /* 15px */
                padding: 0.625rem 1.25rem; /* 10px 20px */
            }
            .game-message {
                font-size: 1rem;
                margin-top: 0.9375rem; /* 15px */
            }
            .card-options {
                padding: 0.5rem; /* 8px */
                gap: 0.3125rem; /* 5px */
            }
            .card-options button {
                padding: 0.5rem 0.75rem; /* 8px 12px */
                font-size: 0.85rem;
            }
            /* Media queries para el modal en pantallas pequeñas */
            .modal-content {
                padding: 1.25rem; /* 20px */
                width: 95%;
            }
            .modal-content h2 {
                font-size: 1.5rem;
            }
            .modal-body {
                gap: 0.625rem; /* 10px */
            }
            .modal-body .card-in-hand {
                width: 5.625rem; /* 90px */
                height: 7.5rem; /* 120px */
            }
            .modal-buttons {
                flex-direction: column;
                gap: 0.625rem; /* 10px */
            }
            .modal-buttons button {
                padding: 0.625rem 1.25rem; /* 10px 20px */
                font-size: 0.9rem;
            }
            .active-effect-card {
                font-size: 0.8rem;
                padding: 0.1875rem 0.5rem; /* 3px 8px */
            }
            .active-effect-card .card-image-small {
                width: 1.875rem; /* 30px */
                height: 1.875rem; /* 30px */
            }
        }

        @media (max-width: 30rem) { /* 480px */
            .card-in-hand {
                width: 8.125rem; /* 130px */
                height: 12.5rem; /* 200px */
            }
            .card-image-container {
                height: 5rem; /* 80px */
            }
            .card-title {
                font-size: 1rem;
            }
            .card-text {
                font-size: 0.75rem;
                -webkit-line-clamp: 3;
            }
            .card-text:hover,
            .card-text.expanded {
                font-size: 0.85rem;
            }
            .board-cell {
                width: 2.5rem; /* 40px */
                height: 2.5rem; /* 40px */
                font-size: 0.8rem;
            }
            .player-token {
                width: 1.75rem; /* 28px */
                height: 1.75rem; /* 28px */
            }
            .game-board {
                height: 6.25rem; /* 100px */
                font-size: 1rem;
            }
        }

        /* Estilos para la pantalla de fin de partida (screen2) */
        #screen2 {
            display: none; /* Oculto por defecto */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 1.875rem; /* 30px */
            gap: 1.5625rem; /* 25px */
            position: relative; /* Para el botón de estado de reinicio */
        }

        #screen2 h1 {
            font-size: 2.5rem;
            color: #FFD700; /* Dorado para el título de fin de partida */
            margin-bottom: 0.625rem; /* 10px */
        }

        #screen2 p {
            font-size: 1.3rem;
            color: #ffffff;
            margin-bottom: 0.3125rem; /* 5px */
        }

        #screen2 .player-names-display {
            font-size: 1.1rem;
            color: #cccccc;
            margin-bottom: 1.25rem; /* 20px */
        }

        #btnRematch {
            padding: 1.125rem 2.5rem; /* 18px 40px */
            font-size: 1.3rem;
            background-color: #FF0000; /* Rojo inicial */
            border-radius: 0.3125rem; /* 5px */
            box-shadow: 0 0.3125rem 0.9375rem rgba(0, 0, 0, 0.5);
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        #btnRematch.ready {
            background-color: #28a745; /* Verde cuando está listo */
        }

        #btnRematch:hover {
            transform: translateY(-0.125rem); /* 2px */
            box-shadow: 0 0.5rem 1.25rem rgba(0, 0, 0, 0.6);
        }

        #btnRematchStatusIndicator {
            position: absolute;
            bottom: 1.25rem; /* 20px */
            left: 1.25rem; /* 20px */
            width: 1.875rem; /* 30px */
            height: 1.875rem; /* 30px */
            border-radius: 50%; /* Circular */
            background-color: #dc3545; /* Rojo inactivo */
            border: 2px solid #ffffff;
            cursor: pointer;
            box-shadow: 0 0.125rem 0.5rem rgba(0, 0, 0, 0.4);
            transition: background-color 0.3s ease;
        }

        #btnRematchStatusIndicator.active {
            background-color: #28a745; /* Verde activo */
        }

        @media (max-width: 48rem) { /* 768px */
            #screen2 h1 {
                font-size: 1.8rem;
            }
            #screen2 p {
                font-size: 1rem;
            }
            #btnRematch {
                padding: 0.75rem 1.5625rem; /* 12px 25px */
                font-size: 1rem;
            }
            #btnRematchStatusIndicator {
                width: 1.5625rem; /* 25px */
                height: 1.5625rem; /* 25px */
                bottom: 0.9375rem; /* 15px */
                left: 0.9375rem; /* 15px */
            }
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
</head>
<body>

    <div id="screen1" class="game-screen active">
        <h1>¡Bienvenido a CS Cards!</h1>
        <div class="input-group">
            <label for="playerName">Introduce tu nombre:</label>
            <input type="text" id="playerName" placeholder="Tu nombre">
            <button id="btnEnterName">Aceptar</button>
        </div>
        <div class="input-group">
            <label for="rivalNameScreen1">Introduce el nombre de tu rival:</label>
            <input type="text" id="rivalNameScreen1" placeholder="Nombre del rival">
        </div>
        <p id="nameError" class="error-message"></p>
        <p id="rivalErrorScreen1" class="error-message"></p>
    </div>

    <div id="screen2" class="game-screen">
        <h1 id="gameOverTitle">¡Partida Terminada!</h1>
        <p id="winnerDisplay"></p>
        <p id="playerNamesDisplay"></p>

        <div class="input-group">
            <label for="playerNameScreen2">Tu nombre:</label>
            <input type="text" id="playerNameScreen2" readonly>
        </div>
        <div class="input-group">
            <label for="rivalNameScreen2">Nombre del rival:</label>
            <input type="text" id="rivalNameScreen2" readonly>
        </div>
        <button id="btnRematch">REINICIAR PARTIDA CONTRA EL MISMO JUGADOR</button>
        <div id="btnRematchStatusIndicator"></div>
    </div>

    <div id="screen3" class="game-screen">
        <div class="player-area opponent-area">
            <span id="opponentNameDisplay">Rival</span>
            <div id="opponentActiveEffects" class="active-effects-container"></div>
            <div class="hand opponent-hand" id="opponentHand">
            </div>
            <div class="deck-discard-area">
                <div class="deck" id="deck">Mazo</div>
                <div class="discard-pile" id="discardPile">Descarte</div>
            </div>
        </div>

        <div class="board-area" id="gameBoard">
            </div>

        <div class="player-area own-area">
            <span id="ownNameDisplay">Tú</span>
            <div id="ownActiveEffects" class="active-effects-container"></div>
            <div class="hand own-hand" id="ownHand">
            </div>
            <button id="btnPassTurn" class="game-button">Pasar Turno</button>
        </div>
        <p id="gameMessage" class="game-message"></p>
    </div>

    <div id="cardInteractionModal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="modalTitle"></h2>
            <div id="modalBody" class="modal-body"></div>
            <div id="modalButtons" class="modal-buttons"></div>
        </div>
    </div>

    <script>
        // Tu configuración de Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyAfK_AOq-Pc2bzgXEzIEZ1ESWvnhMJUvwI",
            authDomain: "enraya-51670.firebaseapp.com",
            databaseURL: "https://enraya-51670-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "enraya-51670",
            storageBucket: "enraya-51670.firebasestorage.app",
            messagingSenderId: "103343380727",
            appId: "1:103343380727:web:b2fa02aee03c9506915bf2",
            measurementId: "G-2G31LLJY1T"
        };

        // Inicializar Firebase
        // Usamos firebase-app-compat y firebase-auth-compat para compatibilidad
        const app = firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();

        // Referencias a los elementos de las pantallas
        const screen1 = document.getElementById('screen1');
        const screen2 = document.getElementById('screen2'); // Nueva pantalla de fin de partida
        const screen3 = document.getElementById('screen3');

        const playerNameInput = document.getElementById('playerName');
        const btnEnterName = document.getElementById('btnEnterName');
        const nameError = document.getElementById('nameError');

        // Elementos del rival ahora en screen1
        const rivalNameInputScreen1 = document.getElementById('rivalNameScreen1');
        const rivalErrorScreen1 = document.getElementById('rivalErrorScreen1');

        const ownNameDisplay = document.getElementById('ownNameDisplay');
        const opponentNameDisplay = document.getElementById('opponentNameDisplay');
        const opponentHandDiv = document.getElementById('opponentHand');
        const ownHandDiv = document.getElementById('ownHand');
        const gameBoardDiv = document.getElementById('gameBoard');
        const discardPileDiv = document.getElementById('discardPile');
        const gameMessageDiv = document.getElementById('gameMessage');

        // Referencias a los elementos del modal
        const cardInteractionModal = document.getElementById('cardInteractionModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        const modalButtons = document.getElementById('modalButtons');

        // Referencias a los contenedores de efectos activos
        const ownActiveEffectsDiv = document.getElementById('ownActiveEffects');
        const opponentActiveEffectsDiv = document.getElementById('opponentActiveEffects');

        // Nuevos elementos de la pantalla de fin de partida (screen2)
        const gameOverTitle = document.getElementById('gameOverTitle');
        const winnerDisplay = document.getElementById('winnerDisplay');
        const playerNamesDisplay = document.getElementById('playerNamesDisplay');
        const playerNameInputScreen2 = document.getElementById('playerNameScreen2');
        const rivalNameInputScreen2 = document.getElementById('rivalNameScreen2');
        const btnRematch = document.getElementById('btnRematch');
        const btnRematchStatusIndicator = document.getElementById('btnRematchStatusIndicator');


        // Variables globales para los nombres de los jugadores y el estado de la partida
        let currentPlayerName = '';
        let rivalPlayerName = '';
        let currentUserId = ''; // UID de Firebase para el jugador actual
        let currentRivalId = ''; // UID de Firebase para el rival
        let currentRoomId = ''; // ID del documento de la sala en Firestore
        let unsubscribeSnapshot = null; // Para desuscribirse de los listeners de Firestore

        // Definición de las cartas
        const cardDefinitions = [
            { id: 'muerte', name: 'Muerte', value: -4.9, effect: 'Elige a un jugador, ese jugador pone sus cartas boca abajo y tú descartas 1 de las cartas. Si esa carta vale 0 o menos, avanzas 1 casilla.', count: 1, image: 'data:image/jpeg;base64,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' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'avefenix', name: 'Ave Fénix', value: -3.3, effect: 'Descarta tu mano y roba 3 cartas.', count: 1, image: 'data:image/jpeg;base64,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' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'gato', name: 'Gato', value: -3, effect: 'Roba 2 cartas.', count: 1, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'caballodetroya', name: 'Caballo de Troya', value: -2.6, effect: 'Elige a un jugador, ese jugador elige 1 de sus cartas y la descarta.', count: 1, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'ranadelasuerte', name: 'Rana de la Suerte', value: -2, effect: 'Avanza 2 casillas.', count: 1, image: 'data:image/jpeg;base64,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' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'perro', name: 'Perro', value: -4, effect: 'El siguiente jugador pierde su turno.', count: 1, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'esclavo', name: 'Esclavo', value: -1, effect: 'Si tienes una carta mayor que 4, puedes mostrarla para avanzar 1 casilla.', count: 2, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'loco', name: 'Loco', value: -0.5, effect: 'Elige a un jugador, ambos mostráis 1 de vuestras cartas, la más alta gana. Ambas cartas son descartadas. El jugador ganador avanza 2 casillas y el perdedor retrocede 1.', count: 1, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'vagabundo', name: 'Vagabundo', value: 0, effect: 'Compara tu carta más baja con la carta más baja de otro jugador, si tu carta es más baja, avanza 2 casillas.', count: 3, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'filosofo', name: 'Filósofo', value: 0.5, effect: 'Elige a un jugador, ambos robáis una carta y la mostráis, si tu carta es más alta, te la quedas y el otro jugador descarta la carta robada. Si tu carta es más baja, ambos jugadores descartáis las cartas robadas.', count: 1, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'nini', name: 'Nini', value: 1, effect: 'Roba 1 carta.', count: 5, image: 'data:image/jpeg;base64,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' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'influencer', name: 'Influencer', value: 2, effect: 'Compara tu carta más alta con la carta más alta del jugador que elijas. El ganador avanza 1 casilla, el perdedor retrocede 1 casilla.', count: 3, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'camello', name: 'Camello', value: 2.1, effect: 'Roba 1 carta, descarta 1 carta. Si muestras una carta de -1 o menor, avanza 1 casilla.', count: 1, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'trabajador', name: 'Trabajador', value: 3, effect: 'Avanza 1 casilla.', count: 5, image: 'data:image/jpeg;base64,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' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'artesano', name: 'Artesano', value: 3.1, effect: 'Si estás en la casilla 0, 1, 2 o 3, avanza 2 casillas. Si estás en la 4 o superior, avanza 1.', count: 1, image: 'data:image/jpeg;base64,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' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'policia', name: 'Policía', value: 4, effect: 'Elige 1 jugador, ese jugador retrocede 1 casilla.', count: 4, image: 'data:image/jpeg;base64,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' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'detective', name: 'Detective', value: 4.7, effect: 'Elige a un jugador y una carta, si ese jugador tiene esa carta: la muestra y retrocede 2 casillas.', count: 1, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'guardaespaldas', name: 'Guardaespaldas', value: 4.9, effect: 'Hasta tu próximo turno, las cartas del resto de jugadores, no te afectan.', count: 2, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'abogado', name: 'Abogado', value: 5, effect: 'Intercambia las cartas con otro jugador.', count: 3, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'banquero', name: 'Banquero', value: 5.9, effect: 'Si la última carta jugada es igual o mayor que 7, avanzas 2 casillas.', count: 1, image: 'data:image/jpeg;base64,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' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'musico', name: 'Músico', value: 6, effect: 'Roba 2 cartas y descarta 2 cartas.', count: 2, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'arlequin', name: 'Arlequín', value: 6.4, effect: 'Roba 2 cartas y descarta 1.', count: 1, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'futbolista', name: 'Futbolista', value: 6.7, effect: 'Descarta 1 carta para avanzar 2 casillas.', count: 1, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'capo', name: 'Capo', value: 7, effect: 'Avanzas 1 casilla. Elige un jugador, el jugador elegido retrocede 1 casilla.', count: 2, image: 'data:image/jpeg;base64,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' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'politico', name: 'Político', value: 8, effect: 'Un jugador, (puedes ser tú), descarta sus cartas y roba la misma cantidad. Avanzas 1 casilla.', count: 1, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'sectario', name: 'Sectario', value: 9, effect: 'Elige un jugador y mira sus cartas, puedes intercambiar tus cartas por las suyas. Avanzas 1 casilla.', count: 1, image: 'data:image/jpeg;base64,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' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'astronauta', name: 'Astronauta', value: 10.5, effect: 'Avanza 1 casilla. Si estás en la casilla 8 o superior, roba 1 carta.', count: 1, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'arcangel', name: 'Arcángel', value: 12, effect: 'Avanza 1 casilla. Roba 3 cartas y descarta 2.', count: 1, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'semidios', name: 'Semidiós', value: 13, effect: 'Avanza 1 casilla. Repite tu turno.', count: 1, image: '' }, /* INSERTAR IMAGEN BASE64 AQUÍ */
            { id: 'ojotodove', name: 'Ojo que todo lo ve', value: 13.9, effect: 'Avanza 1 casilla. Mira las cartas de todos los jugadores.', count: 1, image: 'data:image/jpeg;base64,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' } /* INSERTAR IMAGEN BASE64 AQUÍ */
        ];

        // Lista de IDs de cartas con efectos adversos que pueden ser bloqueados por Guardaespaldas
        const adverseEffectCards = [
            'muerte', 'caballodetroya', 'loco', 'influencer', 'policia', 'detective', 'capo'
        ];

        // Función para cambiar de pantalla
        function showScreen(screenToShow) {
            // Asegurarse de que el modal esté oculto al cambiar de pantalla
            hideModal(); // Add this line
            screen1.classList.remove('active');
            screen2.classList.remove('active'); // Asegurarse de que screen2 también se desactive
            screen3.classList.remove('active');
            screenToShow.classList.add('active');
        }

        // Función para generar una carta visualmente
        function createCardElement(card, isFaceDown = false) {
            const cardDiv = document.createElement('div');
            cardDiv.classList.add('card-in-hand');
            cardDiv.dataset.cardId = card.id; // Almacenar el ID de la carta

            if (isFaceDown) {
                cardDiv.classList.add('card-back');
                cardDiv.innerHTML = 'CS';
            } else {
                cardDiv.innerHTML = `
                    <div class="card-image-container">
                        <img src="${card.image || 'https://placehold.co/120x120/333333/FFFFFF?text=IMAGEN'}" alt="${card.name}">
                    </div>
                    <div class="card-info">
                        <div class="card-title">${card.name}</div>
                        <div class="card-text">${card.effect}</div>
                        <div class="card-stats">
                            <span class="card-stat">Valor: ${card.value}</span>
                        </div>
                    </div>
                `;
                // Añadir listener para expandir/colapsar texto
                const cardTextElement = cardDiv.querySelector('.card-text');
                if (cardTextElement) {
                    cardTextElement.addEventListener('click', (event) => {
                        event.stopPropagation(); // Evitar que el clic se propague a la carta
                        cardTextElement.classList.toggle('expanded');
                    });
                }
            }
            return cardDiv;
        }

        // Función para renderizar la mano del jugador
        function renderOwnHand(hand) {
            console.log("Rendering own hand with card IDs:", hand); // Añadido para depuración
            ownHandDiv.innerHTML = '';
            hand.forEach(cardId => {
                const card = cardDefinitions.find(c => c.id === cardId);
                if (card) {
                    const cardElement = createCardElement(card);
                    cardElement.addEventListener('click', (event) => {
                        // Si el texto ya se expandió con un clic, no mostrar opciones de carta
                        if (!event.target.classList.contains('card-text')) {
                            showCardOptions(cardElement, card);
                        }
                    });
                    ownHandDiv.appendChild(cardElement);
                } else {
                    console.warn("Card definition not found for ID:", cardId); // Añadido para depuración
                }
            });
        }

        // Función para renderizar la mano del oponente (boca abajo)
        function renderOpponentHand(numCards) {
            console.log("Rendering opponent hand with", numCards, "cards (face down)."); // Añadido para depuración
            opponentHandDiv.innerHTML = '';
            for (let i = 0; i < numCards; i++) {
                opponentHandDiv.appendChild(createCardElement({}, true)); // isFaceDown = true
            }
        }

        // Función para mostrar las opciones de una carta (jugar/nada)
        function showCardOptions(cardElement, card) {
            // Eliminar opciones anteriores si existen
            const existingOptions = document.querySelector('.card-options');
            if (existingOptions) {
                existingOptions.remove();
            }

            const optionsDiv = document.createElement('div');
            optionsDiv.classList.add('card-options');

            const playButton = document.createElement('button');
            playButton.textContent = 'Jugar';
            playButton.addEventListener('click', (event) => {
                event.stopPropagation(); // Evitar que el clic se propague
                playCard(card.id);
                optionsDiv.remove();
            });

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Nada';
            cancelButton.addEventListener('click', (event) => {
                event.stopPropagation(); // Evitar que el clic se propague
                optionsDiv.remove();
            });

            optionsDiv.appendChild(playButton);
            optionsDiv.appendChild(cancelButton);
            ownHandDiv.appendChild(optionsDiv); // Añadir al contenedor de la mano para posicionamiento relativo

            // Ajustar la posición después de añadirlo al DOM para que el offsetHeight sea correcto
            optionsDiv.style.top = `${cardElement.offsetTop - optionsDiv.offsetHeight - 10}px`;
            optionsDiv.style.left = `${cardElement.offsetLeft + (cardElement.offsetWidth / 2) - (optionsDiv.offsetWidth / 2)}px`;

            // Cerrar opciones si se clica fuera
            const closeOptions = (event) => {
                if (!optionsDiv.contains(event.target) && !cardElement.contains(event.target)) {
                    optionsDiv.remove();
                    document.removeEventListener('click', closeOptions);
                }
            };
            document.addEventListener('click', closeOptions);
        }


        // Función para renderizar el tablero lineal
        function renderGameBoard(player1Pos, player2Pos) {
            gameBoardDiv.innerHTML = ''; // Limpiar casillas existentes
            const numCells = 14; // De 0 a 13

            for (let i = 0; i < numCells; i++) {
                const cell = document.createElement('div');
                cell.classList.add('board-cell');
                cell.textContent = i;
                cell.dataset.cellIndex = i; // Almacenar el índice de la casilla
                gameBoardDiv.appendChild(cell);
            }

            // Renderizar tokens de jugador
            const player1Token = document.createElement('div');
            player1Token.classList.add('player-token', 'player1-token');
            player1Token.id = 'player1Token';
            gameBoardDiv.appendChild(player1Token);

            const player2Token = document.createElement('div');
            player2Token.classList.add('player-token', 'player2-token');
            player2Token.id = 'player2Token';
            gameBoardDiv.appendChild(player2Token);

            updatePlayerTokens(player1Pos, player2Pos);
        }

        // Función para actualizar la posición de los tokens de jugador en el tablero lineal
        function updatePlayerTokens(player1Pos, player2Pos) {
            const player1Token = document.getElementById('player1Token');
            const player2Token = document.getElementById('player2Token');
            const cells = gameBoardDiv.querySelectorAll('.board-cell');

            if (cells.length > 0) {
                // Posicionar Jugador 1
                const cell1 = cells[player1Pos];
                player1Token.style.left = `${cell1.offsetLeft + (cell1.offsetWidth / 2) - (player1Token.offsetWidth / 2) - 10}px`; /* Ajuste para P1 */
                player1Token.style.top = `${cell1.offsetTop + (cell1.offsetHeight / 2) - (player1Token.offsetHeight / 2)}px`;

                // Posicionar Jugador 2 (ligeramente desplazado si están en la misma casilla)
                const cell2 = cells[player2Pos];
                let offset = 0;
                if (player1Pos === player2Pos) {
                    offset = 10; // Pequeño desplazamiento para que no se superpongan completamente
                }
                player2Token.style.left = `${cell2.offsetLeft + (cell2.offsetWidth / 2) - (player2Token.offsetWidth / 2) + offset}px`; /* Ajuste para P2 */
                player2Token.style.top = `${cell2.offsetTop + (cell2.offsetHeight / 2) - (player2Token.offsetHeight / 2)}px`;
            }
        }

        // Helper function to draw a card, handling reshuffling
        function drawCardForTurn(mazo, pilaDescarte, messageDiv) {
            if (mazo.length === 0) {
                if (pilaDescarte.length > 0) {
                    mazo.push(...shuffleArray(pilaDescarte));
                    pilaDescarte.length = 0;
                    messageDiv.textContent = '¡Mazo barajado con el descarte!';
                } else {
                    messageDiv.textContent = 'No hay cartas en el mazo ni en el descarte para robar.';
                    return null;
                }
            }
            return mazo.shift();
        }

        // --- Lógica de Firebase y Partida ---

        // Función para iniciar sesión anónimamente y obtener el UID
        async function signInAnonymouslyAndGetUid() {
            try {
                const userCredential = await auth.signInAnonymously();
                currentUserId = userCredential.user.uid;
                console.log('Autenticado anónimamente con UID:', currentUserId);
            } catch (error) {
                console.error('Error al autenticar anónimamente:', error);
                gameMessageDiv.textContent = 'Error de autenticación. Por favor, recarga la página.';
            }
        }

        // Función para buscar o crear una sala
        async function findOrCreateRoom(player1Name, player2Name) {
            try {
                const roomsRef = db.collection('SALAS');
                // Buscar salas donde los nombres de los jugadores coincidan en cualquier orden
                const query1 = roomsRef.where('jugador1Nombre', '==', player1Name)
                                      .where('jugador2Nombre', '==', player2Name);
                const query2 = roomsRef.where('jugador1Nombre', '==', player2Name)
                                      .where('jugador2Nombre', '==', player1Name);

                const [snapshot1, snapshot2] = await Promise.all([query1.get(), query2.get()]);

                let roomDoc = null;

                if (!snapshot1.empty) {
                    roomDoc = snapshot1.docs[0];
                } else if (!snapshot2.empty) {
                    roomDoc = snapshot2.docs[0];
                }

                if (roomDoc) {
                    // Sala existente, unirse a ella
                    currentRoomId = roomDoc.id;
                    const roomData = roomDoc.data();
                    const roomRef = db.collection('SALAS').doc(currentRoomId);

                    // Determinar si el jugador actual es el jugador1 o jugador2 en la sala existente
                    if (roomData.jugador1Nombre === currentPlayerName && roomData.jugador1Id === null) {
                        // Si el jugador 1 de la sala no tiene ID, asignárselo (caso de reconexión o error previo)
                        await roomRef.update({
                            jugador1Id: currentUserId,
                            'estadoJuego.gameStatus': roomData.jugador2Id ? 'inProgress' : 'waitingForPlayer',
                            [`estadoJuego.drawStatus.${currentUserId}`]: false, // Initialize draw status for player1 if rejoining
                            [`estadoJuego.rematchStatus.${currentUserId}`]: false // Initialize rematch status for player1
                        });
                        gameMessageDiv.textContent = 'Te has reconectado como Jugador 1.';
                        currentRivalId = roomData.jugador2Id;
                    } else if (roomData.jugador2Nombre === currentPlayerName && roomData.jugador2Id === null) {
                        // Si el jugador 2 de la sala no tiene ID, asignárselo (caso de reconexión o error previo)
                        await roomRef.update({
                            jugador2Id: currentUserId,
                            'estadoJuego.gameStatus': 'inProgress',
                            'estadoJuego.turnoActual': Math.random() < 0.5 ? roomData.jugador1Id : currentUserId,
                            [`estadoJuego.drawStatus.${currentUserId}`]: false, // Initialize draw status for player2
                            [`estadoJuego.rematchStatus.${currentUserId}`]: false // Initialize rematch status for player2
                        });
                        gameMessageDiv.textContent = '¡Te has unido a la partida!';
                        currentRivalId = roomData.jugador1Id;
                    } else if (roomData.jugador1Id === currentUserId || roomData.jugador2Id === currentUserId) {
                        // El jugador ya está en la sala y tiene su ID asignado
                        gameMessageDiv.textContent = 'Reconectando a la partida existente.';
                        if (roomData.jugador1Id === currentUserId) {
                            currentRivalId = roomData.jugador2Id;
                        } else {
                            currentRivalId = roomData.jug1Nombre; // Corrected typo
                        }
                        // Ensure drawStatus and rematchStatus exist for rejoining player if not already
                        if (!roomData.estadoJuego.drawStatus || roomData.estadoJuego.drawStatus[currentUserId] === undefined) {
                            await roomRef.update({
                                [`estadoJuego.drawStatus.${currentUserId}`]: false
                            });
                        }
                        if (!roomData.estadoJuego.rematchStatus || roomData.estadoJuego.rematchStatus[currentUserId] === undefined) {
                            await roomRef.update({
                                [`estadoJuego.rematchStatus.${currentUserId}`]: false
                            });
                        }
                    } else {
                        // La sala existe pero no es para este jugador o ya está llena
                        console.error('Error: Intentando unirse a una sala que ya está llena o no te corresponde.');
                        rivalErrorScreen1.textContent = 'La sala ya está completa o no te corresponde. Intenta con otro nombre de rival.';
                        return; // Evitar mostrar screen3
                    }

                    listenToRoomChanges(currentRoomId);
                    showScreen(screen3);
                } else {
                    // No existe sala, crear una nueva
                    console.log("No existing room found, creating a new one.");
                    const initialDeck = generateInitialDeck();
                    const shuffledDeck = shuffleArray(initialDeck);
                    const initialHand1 = shuffledDeck.splice(0, 3);
                    const initialHand2 = shuffledDeck.splice(0, 3); // Mano inicial para el jugador 2 (vacía si no se unió)

                    const newRoomRef = await roomsRef.add({
                        jugador1Id: currentUserId,
                        jugador1Nombre: player1Name,
                        jugador2Id: null, // Inicialmente nulo
                        jugador2Nombre: player2Name, // Guardar el nombre del rival esperado
                        estadoJuego: {
                            mazo: shuffledDeck,
                            pilaDescarte: [],
                            manoJugador1: initialHand1,
                            manoJugador2: initialHand2,
                            posicionJugador1: 0,
                            posicionJugador2: 0,
                            ultimaCartaJugada: null,
                            turnoActual: null, // Se asignará cuando el segundo jugador se una
                            gameStatus: "waitingForPlayer",
                            ganador: null,
                            efectosActivos: {},
                            drawStatus: { [currentUserId]: false }, // Inicializar drawStatus para el jugador 1
                            rematchStatus: { [currentUserId]: false } // Inicializar rematchStatus para el jugador 1
                        }
                    });
                    currentRoomId = newRoomRef.id;
                    console.log('Sala creada:', currentRoomId);
                    gameMessageDiv.textContent = 'Esperando al rival... (ID de sala: ' + currentRoomId + ')'; // Mostrar ID para depuración
                    listenToRoomChanges(currentRoomId);
                    showScreen(screen3);
                }
            } catch (error) {
                console.error('Error al buscar/crear sala:', error);
                rivalErrorScreen1.textContent = 'Error al conectar. Inténtalo de nuevo.';
            }
        }

        // Función para escuchar cambios en la sala de Firestore
        function listenToRoomChanges(roomId) {
            if (unsubscribeSnapshot) {
                unsubscribeSnapshot(); // Desuscribirse del listener anterior si existe
            }
            const roomRef = db.collection('SALAS').doc(roomId);
            unsubscribeSnapshot = roomRef.onSnapshot(docSnapshot => {
                if (docSnapshot.exists) {
                    const roomData = docSnapshot.data();
                    console.log('Estado de la sala actualizado (onSnapshot):', roomData);
                    console.log('currentUserId (desde onSnapshot):', currentUserId);

                    // Determinar currentRivalId y nombres de forma robusta
                    if (roomData.jugador1Id === currentUserId) {
                        currentRivalId = roomData.jugador2Id;
                        currentPlayerName = roomData.jugador1Nombre;
                        rivalPlayerName = roomData.jugador2Nombre;
                    } else if (roomData.jugador2Id === currentUserId) {
                        currentRivalId = roomData.jug1Nombre;
                        currentPlayerName = roomData.jug2Nombre;
                        rivalPlayerName = roomData.jug1Nombre; // Corrected typo
                    } else {
                        currentRivalId = null;
                        console.error("Error: currentUserId no coincide con ningún jugador en la sala. Esto no debería ocurrir si el jugador está en una sala activa.");
                        // Forzar a volver a la pantalla de inicio si el estado es inconsistente
                        gameMessageDiv.textContent = 'Error en la conexión. Volviendo a la pantalla de inicio.';
                        showScreen(screen1);
                        return;
                    }

                    // Actualizar la UI con los últimos datos de la sala
                    updateGameUI(roomData, roomRef);

                    // Lógica para transiciones de estado del juego y mensajes
                    if (roomData.estadoJuego.gameStatus === "waitingForPlayer") {
                        gameMessageDiv.textContent = 'Esperando al rival... (ID de sala: ' + roomId + ')';
                        btnPassTurn.disabled = true;

                        // Si es el jugador 1, el rival se ha unido y el turno no está asignado, iniciar partida
                        if (roomData.jugador1Id === currentUserId && roomData.jugador2Id && !roomData.estadoJuego.turnoActual) {
                            console.log("Jugador 1 detectó que Jugador 2 se unió. Inicializando estado de juego y turno.");
                            roomRef.update({
                                'estadoJuego.gameStatus': 'inProgress',
                                'estadoJuego.turnoActual': Math.random() < 0.5 ? roomData.jugador1Id : roomData.jugador2Id,
                                [`estadoJuego.drawStatus.${roomData.jugador1Id}`]: false, // Reset draw status for both players on game start
                                [`estadoJuego.drawStatus.${roomData.jugador2Id}`]: false,
                                [`estadoJuego.rematchStatus.${roomData.jugador1Id}`]: false, // Reset rematch status on game start
                                [`estadoJuego.rematchStatus.${roomData.jugador2Id}`]: false
                            }).then(() => {
                                console.log("Estado de juego y turno actualizados por Jugador 1.");
                                gameMessageDiv.textContent = '¡Rival conectado! La partida ha comenzado.';
                            }).catch(error => {
                                console.error('Error al actualizar estado de juego y turno:', error);
                            });
                        }
                    } else if (roomData.estadoJuego.gameStatus === "inProgress") {
                        // El mensaje de turno se maneja en updateGameUI
                        console.log("Juego en progreso. Turno actual:", roomData.estadoJuego.turnoActual);
                    } else if (roomData.estadoJuego.gameStatus === "finished") {
                        gameMessageDiv.textContent = `¡Partida terminada! El ganador es: ${roomData.estadoJuego.ganador === currentUserId ? currentPlayerName : rivalPlayerName}`;
                        btnPassTurn.disabled = true; // Deshabilitar interacciones
                        showScreen(screen2); // Mostrar la pantalla de fin de partida
                        updateGameOverScreen(roomData); // Actualizar la pantalla de fin de partida
                    }

                    // Check for rematch readiness
                    if (roomData.estadoJuego.gameStatus === "finished" && roomData.estadoJuego.rematchStatus) {
                        const ownRematchReady = roomData.estadoJuego.rematchStatus[currentUserId];
                        const opponentRematchReady = roomData.estadoJuego.rematchStatus[currentRivalId];

                        if (ownRematchReady) {
                            btnRematch.classList.add('ready');
                            btnRematchStatusIndicator.classList.add('active');
                            btnRematch.disabled = true; // Disable once ready
                        } else {
                            btnRematch.classList.remove('ready');
                            btnRematchStatusIndicator.classList.remove('active');
                            btnRematch.disabled = false; // Enable if not ready
                        }

                        if (ownRematchReady && opponentRematchReady) {
                            gameMessageDiv.textContent = 'Ambos jugadores listos para la revancha. Reiniciando...';
                            console.log("DEBUG: Ambos jugadores listos para revancha. Reiniciando partida.");
                            resetGame(roomRef, roomData);
                        }
                    }


                } else {
                    console.log('La sala ya no existe.');
                    gameMessageDiv.textContent = 'La partida ha terminado o la sala ha sido eliminada.';
                    showScreen(screen1); // Volver a la pantalla de nombres
                }
            }, error => {
                console.error('Error al escuchar cambios en la sala:', error);
                gameMessageDiv.textContent = 'Error de conexión. Volviendo a la pantalla de selección de rival.';
                showScreen(screen1); // Volver a la pantalla de nombres
            });
        }

        // Función para actualizar la UI del juego con los datos de Firestore
        async function updateGameUI(roomData, roomRef) {
            const gameState = roomData.estadoJuego;

            // Actualizar nombres
            const ownName = roomData.jugador1Id === currentUserId ? roomData.jugador1Nombre : roomData.jugador2Nombre;
            const opponentName = roomData.jugador1Id === currentUserId ? roomData.jugador2Nombre : roomData.jug1Nombre;
            ownNameDisplay.textContent = ownName;
            opponentNameDisplay.textContent = opponentName;
            console.log(`UI Nombres - Propio: ${ownNameDisplay.textContent}, Rival: ${opponentNameDisplay.textContent}`);


            // Actualizar manos
            const ownHand = roomData.jugador1Id === currentUserId ? gameState.manoJugador1 : gameState.manoJugador2;
            const opponentHandCount = roomData.jugador1Id === currentUserId ? gameState.manoJugador2.length : gameState.manoJugador1.length;
            renderOwnHand(ownHand);
            renderOpponentHand(opponentHandCount);

            // Actualizar pila de descarte
            discardPileDiv.innerHTML = '';
            if (gameState.ultimaCartaJugada) {
                const lastCard = cardDefinitions.find(c => c.id === gameState.ultimaCartaJugada);
                if (lastCard) {
                    const lastCardElement = createCardElement(lastCard);
                    lastCardElement.classList.add('last-played-card');
                    discardPileDiv.appendChild(lastCardElement);
                }
            } else {
                discardPileDiv.textContent = 'Descarte';
            }

            // Actualizar tablero y posiciones de jugadores
            const player1Pos = gameState.posicionJugador1;
            const player2Pos = gameState.posicionJugador2;
            renderGameBoard(player1Pos, player2Pos); // Pasar las posiciones tal cual están en Firestore

            // Renderizar efectos activos
            renderActiveEffects(gameState.efectosActivos, roomData.jugador1Id, roomData.jugador2Id, roomData.jugador1Nombre, roomData.jug2Nombre);

            // Indicar turno actual y manejar robo de carta al inicio del turno
            console.log(`DEBUG: UI Turno - Turno actual en Firestore: ${gameState.turnoActual}, Mi UID: ${currentUserId}, Rival UID: ${currentRivalId}`);
            console.log(`DEBUG: UI Turno - drawStatus para ${currentUserId}: ${gameState.drawStatus ? gameState.drawStatus[currentUserId] : 'undefined'}`);
            console.log(`DEBUG: UI Turno - gameStatus: ${gameState.gameStatus}`);

            if (gameState.turnoActual === currentUserId) {
                gameMessageDiv.textContent = '¡Es tu turno!';
                btnPassTurn.disabled = false; // Habilitar botón de pasar turno
                ownHandDiv.style.border = '2px solid #FF0000'; // Resaltar mano del jugador actual con rojo

                // Lógica para robar carta al inicio del turno
                if (gameState.gameStatus === "inProgress" && gameState.drawStatus && gameState.drawStatus[currentUserId] === false) {
                    console.log("DEBUG: UI Turno - Detectado que el jugador actual necesita robar una carta.");
                    const currentMazo = [...gameState.mazo]; // Copia para modificar
                    const currentPilaDescarte = [...gameState.pilaDescarte]; // Copia para modificar
                    const currentOwnHand = roomData.jugador1Id === currentUserId ? [...gameState.manoJugador1] : [...gameState.manoJugador2]; // Asegurarse de usar la mano correcta del estado

                    const newCard = drawCardForTurn(currentMazo, currentPilaDescarte, gameMessageDiv);
                    if (newCard) {
                        currentOwnHand.push(newCard);
                        console.log(`DEBUG: UI Turno - Carta robada: ${newCard}. Nueva mano:`, currentOwnHand);

                        // Actualizar Firestore con la nueva mano, mazo, descarte y estado de robo
                        const updatePayload = {
                            'estadoJuego.mazo': currentMazo,
                            'estadoJuego.pilaDescarte': currentPilaDescarte,
                            [`estadoJuego.drawStatus.${currentUserId}`]: true // Marcar como robado para este turno
                        };

                        if (roomData.jugador1Id === currentUserId) {
                            updatePayload['estadoJuego.manoJugador1'] = currentOwnHand;
                        } else {
                            updatePayload['estadoJuego.manoJugador2'] = currentOwnHand;
                        }

                        try {
                            await roomRef.update(updatePayload);
                            gameMessageDiv.textContent += ' Has robado una carta al inicio de tu turno.';
                            console.log("DEBUG: UI Turno - Firestore actualizado después de robar carta.");
                        } catch (e) {
                            console.error("Error al actualizar Firestore después de robar carta:", e);
                        }
                    } else {
                        console.log("DEBUG: UI Turno - No se pudo robar una carta.");
                    }
                }

            } else if (gameState.turnoActual === currentRivalId) {
                gameMessageDiv.textContent = `Turno de ${opponentNameDisplay.textContent}`;
                btnPassTurn.disabled = true; // Deshabilitar botón de pasar turno
                ownHandDiv.style.border = '1px solid #333333'; // Quitar resaltado con un borde sutil
            } else {
                 gameMessageDiv.textContent = 'Esperando al rival...';
                 btnPassTurn.disabled = true;
                 ownHandDiv.style.border = '1px solid #333333';
            }

            // Verificar condición de victoria
            if (gameState.posicionJugador1 >= 13 || gameState.posicionJugador2 >= 13) {
                const winnerId = gameState.posicionJugador1 >= 13 ? roomData.jugador1Id : roomData.jug2Id;
                // Solo actualiza el estado de la partida a "finished" si aún no lo está
                if (gameState.gameStatus !== "finished") {
                    if (roomRef) { // Asegurarse de que roomRef esté disponible antes de actualizar
                        await roomRef.update({ 'estadoJuego.ganador': winnerId, 'estadoJuego.gameStatus': 'finished' });
                        console.log("DEBUG: Condición de victoria alcanzada. Ganador:", winnerId);
                    } else {
                        console.error("roomRef no está disponible para actualizar el estado de victoria.");
                    }
                }
            }
        }

        // Función para actualizar la pantalla de fin de partida
        function updateGameOverScreen(roomData) {
            const gameState = roomData.estadoJuego;
            const winnerName = gameState.ganador === roomData.jugador1Id ? roomData.jugador1Nombre : roomData.jug2Nombre;
            const ownName = roomData.jugador1Id === currentUserId ? roomData.jug1Nombre : roomData.jug2Nombre;
            const opponentName = roomData.jug1Id === currentUserId ? roomData.jug2Nombre : roomData.jug1Nombre;

            winnerDisplay.textContent = `Ganador: ${winnerName}`;
            playerNamesDisplay.textContent = `Jugadores: ${roomData.jug1Nombre} vs ${roomData.jug2Nombre}`;
            playerNameInputScreen2.value = ownName;
            rivalNameInputScreen2.value = opponentName;

            // Resetear el estado del botón de reinicio para el jugador actual
            btnRematch.classList.remove('ready');
            btnRematchStatusIndicator.classList.remove('active');
            btnRematch.disabled = false; // Habilitar el botón para que el jugador pueda iniciar el reinicio
        }


        // Función para generar el mazo inicial completo
        function generateInitialDeck() {
            let deck = [];
            cardDefinitions.forEach(card => {
                for (let i = 0; i < card.count; i++) {
                    deck.push(card.id);
                }
            });
            return deck;
        }

        // Función para barajar un array (algoritmo Fisher-Yates)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Función para renderizar los efectos activos
        function renderActiveEffects(effectsActivos, jugador1Id, jugador2Id, jugador1Nombre, jugador2Nombre) {
            ownActiveEffectsDiv.innerHTML = '';
            opponentActiveEffectsDiv.innerHTML = '';

            // Determine which player is current user and which is opponent
            const isPlayer1 = currentUserId === jugador1Id;
            const ownPlayerId = currentUserId;
            const opponentPlayerId = isPlayer1 ? jugador2Id : jugador1Id;

            // Render effects for current user
            if (effectsActivos[ownPlayerId] && effectsActivos[ownPlayerId].guardaespaldas) {
                const cardDef = cardDefinitions.find(c => c.id === 'guardaespaldas');
                if (cardDef) {
                    const effectDiv = document.createElement('div');
                    effectDiv.classList.add('active-effect-card');
                    effectDiv.innerHTML = `
                        <div class="card-image-small" style="background-image: url('${cardDef.image || 'https://placehold.co/40x40/333333/FFFFFF?text=IMG'}');"></div>
                        <span>Guardaespaldas activo</span>
                        <span>Activada por: ${ownNameDisplay.textContent}</span>
                    `;
                    ownActiveEffectsDiv.appendChild(effectDiv);
                }
            }

            // Render effects for opponent
            if (effectsActivos[opponentPlayerId] && effectsActivos[opponentPlayerId].guardaespaldas) {
                const cardDef = cardDefinitions.find(c => c.id === 'guardaespaldas');
                if (cardDef) {
                    const effectDiv = document.createElement('div');
                    effectDiv.classList.add('active-effect-card');
                    effectDiv.innerHTML = `
                        <div class="card-image-small" style="background-image: url('${cardDef.image || 'https://placehold.co/40x40/333333/FFFFFF?text=IMG'}');"></div>
                        <span>Guardaespaldas activo</span>
                        <span>Activada por: ${opponentNameDisplay.textContent}</span>
                    `;
                    opponentActiveEffectsDiv.appendChild(effectDiv);
                }
            }
        }


        // --- Lógica de Juego (acciones del jugador) ---

        // Función para jugar una carta
        async function playCard(cardId) {
            // Asegurarse de que es el turno del jugador
            const roomRef = db.collection('SALAS').doc(currentRoomId);
            const roomDoc = await roomRef.get();
            const roomData = roomDoc.data();
            const gameState = roomDoc.data().estadoJuego; // Obtener el estado de juego actualizado

            if (gameState.turnoActual !== currentUserId) {
                gameMessageDiv.textContent = '¡No es tu turno!';
                console.log("DEBUG: playCard - No es tu turno.");
                return;
            }
            console.log(`DEBUG: playCard - Jugando carta: ${cardDefinitions.find(c => c.id === cardId).name}`);
            gameMessageDiv.textContent = `Jugando ${cardDefinitions.find(c => c.id === cardId).name}...`;

            let ownHand = roomData.jugador1Id === currentUserId ? [...gameState.manoJugador1] : [...gameState.manoJugador2];
            let rivalHand = roomData.jugador1Id === currentUserId ? [...gameState.manoJugador2] : [...gameState.manoJugador1];
            let ownPos = roomData.jugador1Id === currentUserId ? gameState.posicionJugador1 : gameState.posicionJugador2;
            let rivalPos = roomData.jugador1Id === currentUserId ? gameState.posicionJugador2 : gameState.posicionJugador1;
            let mazo = [...gameState.mazo];
            let pilaDescarte = [...gameState.pilaDescarte];
            const lastPlayedCardId = gameState.ultimaCartaJugada;
            let effectsActivos = {...gameState.efectosActivos}; // Copy effects

            const cardIndex = ownHand.indexOf(cardId);
            if (cardIndex === -1) {
                gameMessageDiv.textContent = 'Esa carta no está en tu mano.';
                console.log("DEBUG: playCard - Carta no encontrada en mano.");
                return;
            }

            const playedCard = cardDefinitions.find(c => c.id === cardId);
            ownHand.splice(cardIndex, 1); // Remover la carta de la mano
            pilaDescarte.push(cardId); // Añadirla a la pila de descarte

            // Crear un objeto de estado mutable para pasar a applyCardEffect
            let mutableState = {
                ownHand: ownHand,
                rivalHand: rivalHand,
                ownPos: ownPos,
                rivalPos: rivalPos,
                mazo: mazo,
                pilaDescarte: pilaDescarte,
                lastPlayedCardId: lastPlayedCardId,
                currentUserId: currentUserId,
                currentRivalId: currentRivalId,
                roomData: roomData,
                roomRef: roomRef,
                effectsActivos: effectsActivos // Pass effects to mutableState
            };

            // Aplicar efecto de la carta, modificando mutableState
            await applyCardEffect(playedCard, mutableState);

            // Determinar el próximo turno. Si la carta es Semidiós, el turno se repite.
            let nextTurnPlayerId = currentRivalId;
            let newDrawStatus = {...gameState.drawStatus}; // Copy drawStatus

            if (playedCard.id === 'semidios') {
                nextTurnPlayerId = currentUserId; // Repetir turno
                newDrawStatus[currentUserId] = false; // Reset draw status for repeated turn
                gameMessageDiv.textContent += ' ¡Repites tu turno!';
                console.log("DEBUG: playCard - Semidiós jugado. Repitiendo turno y reseteando drawStatus para el jugador actual.");
            } else {
                newDrawStatus[currentRivalId] = false; // Reset draw status for the next player
                console.log("DEBUG: playCard - Turno normal. Reseteando drawStatus para el rival.");
            }

            // Actualizar el estado en Firestore con los valores modificados de mutableState
            let updatedGameState = {
                ...gameState,
                mazo: mutableState.mazo,
                pilaDescarte: mutableState.pilaDescarte,
                ultimaCartaJugada: cardId,
                manoJugador1: roomData.jugador1Id === currentUserId ? mutableState.ownHand : mutableState.rivalHand,
                manoJugador2: roomData.jugador1Id === currentUserId ? mutableState.rivalHand : mutableState.ownHand,
                posicionJugador1: roomData.jugador1Id === currentUserId ? mutableState.ownPos : mutableState.rivalPos,
                posicionJugador2: roomData.jugador1Id === currentUserId ? mutableState.rivalPos : mutableState.ownPos,
                turnoActual: nextTurnPlayerId, // Pasar el turno al rival o repetir
                efectosActivos: mutableState.effectsActivos, // Update effects from mutableState
                drawStatus: newDrawStatus // Update drawStatus
            };
            console.log("DEBUG: playCard - Estado del juego a actualizar en Firestore:", updatedGameState);

            await roomRef.update({ estadoJuego: updatedGameState });
            gameMessageDiv.textContent = `Has jugado ${playedCard.name}. Turno de ${opponentNameDisplay.textContent}.`;
        }

        // Función auxiliar para elegir un jugador (simplificado por ahora)
        // NOTA: Para una experiencia multijugador completa, esto debería ser un modal interactivo
        // que permita al jugador actual elegir entre sí mismo o el rival, y que el rival reciba una notificación.
        async function choosePlayer() {
            console.log("DEBUG: choosePlayer llamado. Por simplicidad, siempre se elige al rival.");
            // Por ahora, siempre elegimos al rival para efectos que afectan a "otro jugador".
            // Para efectos donde se puede elegir "a ti mismo o a otro", se necesitaría una UI.
            return currentRivalId;
        }

        // Función para mostrar un modal interactivo
        function showModal(title, contentHtml, buttons, customClass = '') {
            return new Promise(resolve => {
                modalTitle.textContent = title;
                modalBody.innerHTML = ''; // Limpiar contenido previo
                modalBody.appendChild(contentHtml); // Añadir el contenido HTML proporcionado

                modalButtons.innerHTML = ''; // Limpiar botones previos
                buttons.forEach(btn => {
                    const buttonElement = document.createElement('button');
                    buttonElement.textContent = btn.text;
                    buttonElement.addEventListener('click', () => {
                        hideModal();
                        resolve(btn.action); // Resolver la promesa con la acción del botón
                    });
                    modalButtons.appendChild(buttonElement);
                });

                // Add custom class if provided
                if (customClass) {
                    cardInteractionModal.querySelector('.modal-content').classList.add(customClass);
                }

                cardInteractionModal.style.display = 'flex'; // Mostrar el modal
            });
        }

        // Función para ocultar el modal
        function hideModal() {
            cardInteractionModal.style.display = 'none';
            modalTitle.textContent = '';
            modalBody.innerHTML = '';
            modalButtons.innerHTML = '';
            // Remove any custom class when hiding
            cardInteractionModal.querySelector('.modal-content').classList.remove('discard-modal-content');
            cardInteractionModal.querySelector('.modal-content').classList.remove('select-card-modal'); // Remove select-card-modal class
        }

        // New function to allow player to choose cards to discard
        async function chooseCardsToDiscard(hand, numToDiscard, targetPlayerName) {
            return new Promise(resolve => {
                let selectedCards = [];
                const discardContainer = document.createElement('div');
                discardContainer.classList.add('hand'); // Reuse hand styling
                discardContainer.style.flexWrap = 'wrap';
                discardContainer.style.justifyContent = 'center';
                discardContainer.style.gap = '15px';
                // Border styling will be applied via .discard-modal-content class on the modal-content itself

                const selectionCounter = document.createElement('p');
                selectionCounter.style.color = 'white';
                selectionCounter.style.fontSize = '1.2em';
                selectionCounter.style.marginBottom = '15px';
                selectionCounter.textContent = `Elige las cartas a descartar: 0/${numToDiscard}`;

                const confirmButton = document.createElement('button');
                confirmButton.textContent = 'Confirmar Descarte';
                confirmButton.disabled = true; // Disabled until correct number of cards are selected

                // Function to update the counter and button state
                const updateSelection = () => {
                    selectionCounter.textContent = `Elige las cartas a descartar: ${selectedCards.length}/${numToDiscard}`;
                    confirmButton.disabled = selectedCards.length !== numToDiscard;
                };

                // Create card elements for selection
                hand.forEach(cardId => {
                    const card = cardDefinitions.find(c => c.id === cardId);
                    if (card) {
                        const cardElement = createCardElement(card);
                        cardElement.classList.add('selectable'); // Add selectable class for styling
                        cardElement.addEventListener('click', () => {
                            const index = selectedCards.indexOf(cardId);
                            if (index > -1) {
                                // Card already selected, deselect it
                                selectedCards.splice(index, 1);
                                cardElement.classList.remove('selected');
                            } else if (selectedCards.length < numToDiscard) {
                                // Card not selected and we can select more
                                selectedCards.push(cardId);
                                cardElement.classList.add('selected');
                            }
                            updateSelection();
                        });
                        discardContainer.appendChild(cardElement);
                    }
                });

                confirmButton.addEventListener('click', () => {
                    hideModal(); // Hide the modal when confirmed
                    resolve(selectedCards);
                });

                const modalContentDiv = document.createElement('div');
                modalContentDiv.appendChild(selectionCounter);
                modalContentDiv.appendChild(discardContainer);

                // Show the modal with the custom class
                showModal(
                    `Descartar Cartas (${targetPlayerName})`,
                    modalContentDiv,
                    [], // No default buttons, we'll add our custom one
                    'discard-modal-content' // Custom class for styling
                );

                // Manually add the confirm button to the modalButtons div
                modalButtons.innerHTML = ''; // Clear existing buttons
                modalButtons.appendChild(confirmButton);
            });
        }

        // New function to allow player to choose a card from all definitions
        async function chooseCardFromAllDefinitions(promptText) {
            return new Promise(resolve => {
                const selectionContainer = document.createElement('div');
                selectionContainer.classList.add('hand');
                selectionContainer.style.flexWrap = 'wrap';
                selectionContainer.style.justifyContent = 'center';
                selectionContainer.style.gap = '10px';

                const promptElement = document.createElement('p');
                promptElement.style.color = 'white';
                promptElement.style.fontSize = '1.2em';
                promptElement.style.marginBottom = '15px';
                promptElement.textContent = promptText;

                let selectedCardId = null;

                cardDefinitions.forEach(card => {
                    const cardElement = createCardElement(card);
                    cardElement.classList.add('selectable');
                    cardElement.style.cursor = 'pointer';
                    cardElement.addEventListener('click', () => {
                        // Deselect previous card if any
                        const prevSelected = selectionContainer.querySelector('.card-in-hand.selected');
                        if (prevSelected) {
                            prevSelected.classList.remove('selected');
                        }
                        // Select current card
                        cardElement.classList.add('selected');
                        selectedCardId = card.id;
                        confirmButton.disabled = false; // Enable confirm button
                    });
                    selectionContainer.appendChild(cardElement);
                });

                const confirmButton = document.createElement('button');
                confirmButton.textContent = 'Confirmar Selección';
                confirmButton.disabled = true; // Disabled until a card is selected

                confirmButton.addEventListener('click', () => {
                    hideModal();
                    resolve(selectedCardId);
                });

                const modalContentDiv = document.createElement('div');
                modalContentDiv.appendChild(promptElement);
                modalContentDiv.appendChild(selectionContainer);

                showModal(
                    'Seleccionar Carta',
                    modalContentDiv,
                    [],
                    'select-card-modal' // Optional custom class for this modal
                );

                modalButtons.innerHTML = '';
                modalButtons.appendChild(confirmButton);
            });
        }


        // Función para aplicar los efectos de las cartas
        async function applyCardEffect(card, state) {
            // Desestructurar el estado para facilitar el acceso y la modificación
            let { ownHand, rivalHand, ownPos, rivalPos, mazo, pilaDescarte, lastPlayedCardId, currentUserId, currentRivalId, roomData, roomRef, effectsActivos } = state;
            const isPlayer1 = roomData.jugador1Id === currentUserId;

            console.log(`DEBUG: applyCardEffect - Aplicando efecto de carta: ${card.name}`);
            console.log("DEBUG: applyCardEffect - Estado inicial del efecto:", { ownHand: [...ownHand], rivalHand: [...rivalHand], ownPos, rivalPos, mazo: [...mazo], pilaDescarte: [...pilaDescarte], effectsActivos: {...effectsActivos} });

            // Función auxiliar para robar cartas, manejando el barajado del descarte (para efectos)
            const drawCardForEffect = () => {
                if (mazo.length === 0) {
                    if (pilaDescarte.length > 0) {
                        mazo.push(...shuffleArray(pilaDescarte));
                        pilaDescarte.length = 0; // Vaciar pila de descarte
                        gameMessageDiv.textContent = '¡Mazo barajado con el descarte!';
                        console.log("DEBUG: drawCardForEffect - Mazo barajado con descarte. Nuevo mazo:", mazo);
                    } else {
                        gameMessageDiv.textContent = 'No hay cartas en el mazo ni en el descarte para robar.';
                        console.log("DEBUG: drawCardForEffect - No hay cartas para robar.");
                        return null; // No hay cartas para robar
                    }
                }
                const drawnCard = mazo.shift(); // Roba la primera carta del mazo
                console.log("DEBUG: drawCardForEffect - Carta robada:", drawnCard);
                return drawnCard;
            };

            // Función para verificar si un efecto adverso debe ser bloqueado por Guardaespaldas
            const isEffectBlockedByGuardaespaldas = (targetPlayerId) => {
                return effectsActivos[targetPlayerId] && effectsActivos[targetPlayerId].guardaespaldas;
            };

            switch (card.id) {
                case 'muerte':
                    console.log("DEBUG: Efecto Muerte activado.");
                    // Muerte: El jugador actual descarta 1 carta de la mano del rival
                    if (isEffectBlockedByGuardaespaldas(currentRivalId)) {
                        gameMessageDiv.textContent = `${opponentNameDisplay.textContent} está protegido por Guardaespaldas. ¡El efecto Muerte es bloqueado!`;
                        console.log("DEBUG: Muerte: Efecto bloqueado por Guardaespaldas.");
                        break; // Salir del efecto
                    }

                    const discardedCardsMuerte = await chooseCardsToDiscard(rivalHand, 1, opponentNameDisplay.textContent);

                    if (discardedCardsMuerte && discardedCardsMuerte.length > 0) {
                        const discardedCardId = discardedCardsMuerte[0];
                        const index = rivalHand.indexOf(discardedCardId);
                        if (index > -1) {
                            rivalHand.splice(index, 1);
                            pilaDescarte.push(discardedCardId);
                            const discardedCardMuerteDef = cardDefinitions.find(c => c.id === discardedCardId);
                            gameMessageDiv.textContent = `${opponentNameDisplay.textContent} ha descartado ${discardedCardMuerteDef.name}.`;
                            console.log("DEBUG: Muerte: Carta descartada del rival:", discardedCardMuerteDef.name);

                            if (discardedCardMuerteDef.value <= 0) {
                                ownPos = Math.min(13, ownPos + 1);
                                gameMessageDiv.textContent += ' ¡Has avanzado 1 casilla!';
                                console.log("DEBUG: Muerte: Avanza 1 casilla. Nueva posición:", ownPos);
                            }
                        }
                    } else {
                        gameMessageDiv.textContent = 'No se seleccionó ninguna carta para descartar.';
                        console.log("DEBUG: Muerte: No se seleccionó ninguna carta para descartar.");
                    }
                    break;

                case 'avefenix':
                    console.log("DEBUG: Efecto Ave Fénix activado.");
                    // Descarta toda la mano
                    while(ownHand.length > 0) {
                        pilaDescarte.push(ownHand.pop());
                    }
                    for (let i = 0; i < 3; i++) {
                        const newCard = drawCardForEffect();
                        if (newCard) ownHand.push(newCard);
                    }
                    gameMessageDiv.textContent = 'Has descartado tu mano y robado 3 cartas.';
                    console.log("DEBUG: Ave Fénix: Mano actualizada:", ownHand);
                    break;

                case 'gato':
                    console.log("DEBUG: Efecto Gato activado.");
                    for (let i = 0; i < 2; i++) {
                        const newCard = drawCardForEffect();
                        if (newCard) ownHand.push(newCard);
                    }
                    gameMessageDiv.textContent += ' Has robado 2 cartas.';
                    console.log("DEBUG: Gato: Mano actualizada:", ownHand);
                    break;

                case 'caballodetroya':
                    console.log("DEBUG: Efecto Caballo de Troya activado.");
                    // Caballo de Troya: El jugador elegido (rival) descarta 1 de sus cartas
                    // Simulación: el rival descarta la carta de menor valor.
                    if (isEffectBlockedByGuardaespaldas(currentRivalId)) {
                        gameMessageDiv.textContent = `${opponentNameDisplay.textContent} está protegido por Guardaespaldas. ¡El efecto Caballo de Troya es bloqueado!`;
                        console.log("DEBUG: Caballo de Troya: Efecto bloqueado por Guardaespaldas.");
                        break; // Salir del efecto
                    }

                    if (rivalHand.length > 0) {
                        const lowestCardInRivalHand = rivalHand.reduce((minCardId, currentCardId) => {
                            const minCardDef = cardDefinitions.find(c => c.id === minCardId);
                            const currentCardDef = cardDefinitions.find(c => c.id === currentCardId);
                            return (!minCardDef || (currentCardDef && currentCardDef.value < minCardDef.value)) ? currentCardId : minCardId;
                        }, rivalHand[0]); // Start with the first card as initial min

                        const index = rivalHand.indexOf(lowestCardInRivalHand);
                        if (index > -1) {
                            rivalHand.splice(index, 1);
                            pilaDescarte.push(lowestCardInRivalHand);
                            const discardedCardTroyaDef = cardDefinitions.find(c => c.id === lowestCardInRivalHand);
                            gameMessageDiv.textContent = `${opponentNameDisplay.textContent} ha descartado ${discardedCardTroyaDef.name} (la de menor valor).`;
                            console.log("DEBUG: Caballo de Troya: Rival descartó automáticamente:", discardedCardTroyaDef.name);
                        }
                    } else {
                        gameMessageDiv.textContent = `${opponentNameDisplay.textContent} no tiene cartas para descartar.`;
                        console.log("DEBUG: Caballo de Troya: Rival sin cartas.");
                    }
                    break;

                case 'ranadelasuerte':
                    console.log("DEBUG: Efecto Rana de la Suerte activado.");
                    ownPos = Math.min(13, ownPos + 2);
                    gameMessageDiv.textContent += ' ¡Has avanzado 2 casillas!';
                    console.log("DEBUG: Rana de la Suerte: Nueva posición:", ownPos);
                    break;

                case 'perro':
                    console.log("DEBUG: Efecto Perro activado.");
                    // En un juego de 2 jugadores, si el siguiente jugador pierde su turno,
                    // el jugador actual efectivamente repite su turno.
                    effectsActivos.nextPlayerLosesTurn = true;
                    gameMessageDiv.textContent += ` ${opponentNameDisplay.textContent} perderá su turno. ¡Repites turno!`;
                    console.log("DEBUG: Perro: Efecto 'nextPlayerLosesTurn' activado. En 2 jugadores, esto significa que el jugador actual repetirá turno.");
                    break;

                case 'esclavo':
                    console.log("DEBUG: Efecto Esclavo activado.");
                    // Encuentra la carta con valor > 4 en la mano del jugador
                    const cardToRevealEsclavoId = ownHand.find(cId => {
                        const cardDef = cardDefinitions.find(cd => cd.id === cId);
                        return cardDef && cardDef.value > 4;
                    });

                    if (cardToRevealEsclavoId) {
                        const cardToRevealEsclavo = cardDefinitions.find(c => c.id === cardToRevealEsclavoId);
                        // Mostrar la carta en un modal
                        const revealedCardDiv = document.createElement('div');
                        revealedCardDiv.classList.add('hand');
                        revealedCardDiv.appendChild(createCardElement(cardToRevealEsclavo));
                        await showModal(
                            'Carta Mostrada (Esclavo)',
                            revealedCardDiv,
                            [{ text: 'Cerrar', action: 'close' }]
                        );

                        ownPos = Math.min(13, ownPos + 1);
                        gameMessageDiv.textContent += ` ¡Has mostrado la carta ${cardToRevealEsclavo.name} y avanzado 1 casilla!`;
                        console.log("DEBUG: Esclavo: Avanza 1 casilla. Nueva posición:", ownPos);
                    } else {
                        gameMessageDiv.textContent += ' No tienes una carta mayor que 4 para mostrar.';
                        console.log("DEBUG: Esclavo: No hay carta para mostrar.");
                    }
                    break;

                case 'loco':
                    console.log("DEBUG: Efecto Loco activado.");
                    const targetPlayerIdLoco = await choosePlayer(); // Elegir rival
                    let targetHandLoco = (isPlayer1 && targetPlayerIdLoco === currentRivalId) ? rivalHand : ownHand;

                    if (isEffectBlockedByGuardaespaldas(targetPlayerIdLoco)) {
                        gameMessageDiv.textContent = `${opponentNameDisplay.textContent} está protegido por Guardaespaldas. ¡El efecto Loco es bloqueado!`;
                        console.log("DEBUG: Loco: Efecto bloqueado por Guardaespaldas.");
                        break; // Salir del efecto
                    }

                    if (ownHand.length === 0 || targetHandLoco.length === 0) {
                        gameMessageDiv.textContent = 'Uno de los jugadores no tiene cartas para el efecto Loco.';
                        console.log("DEBUG: Loco: Jugador sin cartas.");
                        break;
                    }

                    // Por simplicidad, se eligen las primeras cartas de cada mano
                    const ownCardLocoId = ownHand[0];
                    const rivalCardLocoId = targetHandLoco[0];

                    const ownCardLoco = cardDefinitions.find(c => c.id === ownCardLocoId);
                    const rivalCardLoco = cardDefinitions.find(c => c.id === rivalCardLocoId);

                    if (ownCardLoco && rivalCardLoco) {
                        // Mostrar las cartas en un modal
                        const comparisonCardsDivLoco = document.createElement('div');
                        comparisonCardsDivLoco.classList.add('hand');
                        comparisonCardsDivLoco.style.justifyContent = 'space-around';
                        comparisonCardsDivLoco.style.width = '100%';
                        comparisonCardsDivLoco.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                                <span>Tu Carta:</span>
                                ${createCardElement(ownCardLoco).outerHTML}
                            </div>
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                                <span>Carta del Rival:</span>
                                ${createCardElement(rivalCardLoco).outerHTML}
                            </div>
                        `;
                        await showModal(
                            'Comparación de Cartas (Loco)',
                            comparisonCardsDivLoco,
                            [{ text: 'Cerrar', action: 'close' }]
                        );

                        // Remover las cartas de las manos y moverlas a la pila de descarte
                        ownHand.splice(ownHand.indexOf(ownCardLocoId), 1);
                        pilaDescarte.push(ownCardLocoId);
                        targetHandLoco.splice(targetHandLoco.indexOf(rivalCardLocoId), 1);
                        pilaDescarte.push(rivalCardLocoId);

                        gameMessageDiv.textContent = `Ambos mostráis: Tú ${ownCardLoco.name}, Rival ${rivalCardLoco.name}.`;
                        console.log("DEBUG: Loco: Cartas descartadas:", ownCardLoco.name, rivalCardLoco.name);

                        if (ownCardLoco.value > rivalCardLoco.value) {
                            ownPos = Math.min(13, ownPos + 2);
                            rivalPos = Math.max(0, rivalPos - 1);
                            gameMessageDiv.textContent += ` ¡Has ganado la comparación con Loco! Avanzas 2, el rival retrocede 1.`;
                            console.log("DEBUG: Loco: Gana propio. Posiciones:", ownPos, rivalPos);
                        } else if (rivalCardLoco.value > ownCardLoco.value) {
                            ownPos = Math.max(0, ownPos - 1);
                            rivalPos = Math.min(13, rivalPos + 2);
                            gameMessageDiv.textContent += ` ¡El rival ha ganado la comparación con Loco! Tú retrocedes 1, el rival avanza 2.`;
                            console.log("DEBUG: Loco: Gana rival. Posiciones:", ownPos, rivalPos);
                        } else {
                            gameMessageDiv.textContent += ` Empate en la comparación de Loco. Nadie avanza ni retrocede.`;
                            console.log("DEBUG: Loco: Empate.");
                        }
                    }
                    if (isPlayer1 && targetPlayerIdLoco === currentRivalId) { rivalHand = targetHandLoco; } else if (targetPlayerIdLoco === currentUserId) { ownHand = targetHandLoco; }
                    break;

                case 'vagabundo':
                    console.log("DEBUG: Efecto Vagabundo activado.");
                    const targetPlayerIdVagabundo = await choosePlayer(); // Elegir rival
                    const targetHandVagabundo = (isPlayer1 && targetPlayerIdVagabundo === currentRivalId) ? rivalHand : ownHand;

                    if (ownHand.length === 0 || targetHandVagabundo.length === 0) {
                        gameMessageDiv.textContent = 'Uno de los jugadores no tiene cartas para el efecto Vagabundo.';
                        console.log("DEBUG: Vagabundo: Jugador sin cartas.");
                        break;
                    }

                    const ownLowestCard = ownHand.reduce((minCard, cardId) => {
                        const card = cardDefinitions.find(c => c.id === cardId);
                        return (!minCard || (card && card.value < minCard.value)) ? card : minCard;
                    }, {value: Infinity}); // Initialize with a very high value

                    const rivalLowestCard = targetHandVagabundo.reduce((minCard, cardId) => {
                        const card = cardDefinitions.find(c => c.id === cardId);
                        return (!minCard || (card && card.value < minCard.value)) ? card : minCard;
                    }, {value: Infinity}); // Initialize with a very high value

                    if (ownLowestCard.value !== Infinity && rivalLowestCard.value !== Infinity) {
                        gameMessageDiv.textContent = `Comparando cartas más bajas: Tú ${ownLowestCard.name}, Rival ${rivalLowestCard.name}.`;
                        console.log("DEBUG: Vagabundo: Cartas más bajas - Propia:", ownLowestCard.name, "Rival:", rivalLowestCard.name);
                        if (ownLowestCard.value < rivalLowestCard.value) {
                            ownPos = Math.min(13, ownPos + 2);
                            gameMessageDiv.textContent += ` Tu carta más baja (${ownLowestCard.name}) es menor. Avanzas 2 casillas.`;
                            console.log("DEBUG: Vagabundo: Avanza 2 casillas. Nueva posición:", ownPos);
                        } else {
                            gameMessageDiv.textContent += ` Tu carta más baja (${ownLowestCard.name}) no es menor que la del rival.`;
                            console.log("DEBUG: Vagabundo: No avanza.");
                        }
                    } else {
                        gameMessageDiv.textContent = 'No se pudieron encontrar las cartas más bajas para la comparación.';
                        console.log("DEBUG: Vagabundo: No se pudieron encontrar las cartas más bajas.");
                    }
                    break;

                case 'filosofo':
                    console.log("DEBUG: Efecto Filósofo activado.");
                    const targetPlayerIdFilosofo = await choosePlayer(); // Elegir rival
                    let targetHandFilosofo = (isPlayer1 && targetPlayerIdFilosofo === currentRivalId) ? rivalHand : ownHand;

                    const ownDrawnCardId = drawCardForEffect();
                    const rivalDrawnCardId = drawCardForEffect();

                    if (!ownDrawnCardId || !rivalDrawnCardId) {
                        gameMessageDiv.textContent = 'No hay suficientes cartas en el mazo para el efecto Filósofo.';
                        // Devolver las cartas robadas al mazo si no se pueden completar las dos
                        if (ownDrawnCardId) mazo.push(ownDrawnCardId);
                        if (rivalDrawnCardId) mazo.push(rivalDrawnCardId);
                        console.log("DEBUG: Filósofo: Mazo insuficiente.");
                        break;
                    }

                    const ownDrawnCard = cardDefinitions.find(c => c.id === ownDrawnCardId);
                    const rivalDrawnCard = cardDefinitions.find(c => c.id === rivalDrawnCardId);

                    // Crear el contenido HTML para mostrar ambas cartas
                    const comparisonCardsDiv = document.createElement('div');
                    comparisonCardsDiv.classList.add('hand'); // Reutilizar estilos de mano
                    comparisonCardsDiv.style.justifyContent = 'space-around'; // Espaciar las cartas
                    comparisonCardsDiv.style.width = '100%';

                    const ownCardElement = createCardElement(ownDrawnCard);
                    const rivalCardElement = createCardElement(rivalDrawnCard);

                    comparisonCardsDiv.innerHTML = `
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <span>Tu Carta:</span>
                            ${ownCardElement.outerHTML}
                        </div>
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
                            <span>Carta del Rival:</span>
                            ${rivalCardElement.outerHTML}
                            </div>
                        `;

                    await showModal(
                        'Comparación de Cartas (Filósofo)',
                        comparisonCardsDiv,
                        [{ text: 'Cerrar', action: 'close' }]
                    );

                    gameMessageDiv.textContent = `Ambos robáis: Tú ${ownDrawnCard.name}, Rival ${rivalDrawnCard.name}.`;
                    console.log("DEBUG: Filósofo: Cartas robadas - Propia:", ownDrawnCard.name, "Rival:", rivalDrawnCard.name);

                    if (ownDrawnCard.value > rivalDrawnCard.value) {
                        ownHand.push(ownDrawnCardId);
                        pilaDescarte.push(rivalDrawnCardId);
                        gameMessageDiv.textContent += ` Tu carta es más alta, te la quedas y el rival descarta la suya.`;
                        console.log("DEBUG: Filósofo: Propia más alta.");
                    } else if (ownDrawnCard.value < rivalDrawnCard.value) {
                        pilaDescarte.push(ownDrawnCardId);
                        pilaDescarte.push(rivalDrawnCardId);
                        gameMessageDiv.textContent += ` Tu carta es más baja, ambos descartáis las cartas.`;
                        console.log("DEBUG: Filósofo: Rival más alta.");
                    } else {
                        pilaDescarte.push(ownDrawnCardId);
                        pilaDescarte.push(rivalDrawnCardId);
                        gameMessageDiv.textContent += ` Empate, ambos descartáis las cartas.`;
                        console.log("DEBUG: Filósofo: Empate.");
                    }
                    if (isPlayer1 && targetPlayerIdFilosofo === currentRivalId) { rivalHand = targetHandFilosofo; } else if (targetPlayerIdFilosofo === currentUserId) { ownHand = targetHandFilosofo; }
                    break;

                case 'nini':
                    console.log("DEBUG: Efecto Nini activado.");
                    const newCardNini = drawCardForEffect();
                    if (newCardNini) ownHand.push(newCardNini);
                    gameMessageDiv.textContent += ' Has robado 1 carta.';
                    console.log("DEBUG: Nini: Mano actualizada:", ownHand);
                    break;

                case 'influencer':
                    console.log("DEBUG: Efecto Influencer activado.");
                    const targetPlayerIdInfluencer = await choosePlayer(); // Elegir rival
                    const targetHandInfluencer = (isPlayer1 && targetPlayerIdInfluencer === currentRivalId) ? rivalHand : ownHand;

                    if (isEffectBlockedByGuardaespaldas(targetPlayerIdInfluencer)) {
                        gameMessageDiv.textContent = `${opponentNameDisplay.textContent} está protegido por Guardaespaldas. ¡El efecto Influencer es bloqueado!`;
                        console.log("DEBUG: Influencer: Efecto bloqueado por Guardaespaldas.");
                        break; // Salir del efecto
                    }

                    if (ownHand.length === 0 || targetHandInfluencer.length === 0) {
                        gameMessageDiv.textContent = 'Uno de los jugadores no tiene cartas para el efecto Influencer.';
                        console.log("DEBUG: Influencer: Jugador sin cartas.");
                        break;
                    }

                    const ownHighestCard = ownHand.reduce((maxCard, cardId) => {
                        const card = cardDefinitions.find(c => c.id === cardId);
                        return (!maxCard || (card && card.value > maxCard.value)) ? card : maxCard;
                    }, {value: -Infinity}); // Initialize with a very low value

                    const rivalHighestCard = targetHandInfluencer.reduce((maxCard, cardId) => {
                        const card = cardDefinitions.find(c => c.id === cardId);
                        return (!maxCard || (card && card.value > maxCard.value)) ? card : maxCard;
                    }, {value: -Infinity}); // Initialize with a very low value

                    if (ownHighestCard.value !== -Infinity && rivalHighestCard.value !== -Infinity) {
                        gameMessageDiv.textContent = `Comparando cartas más altas: Tú ${ownHighestCard.name}, Rival ${rivalHighestCard.name}.`;
                        console.log("DEBUG: Influencer: Cartas más altas - Propia:", ownHighestCard.name, "Rival:", rivalHighestCard.name);
                        if (ownHighestCard.value > rivalHighestCard.value) {
                            ownPos = Math.min(13, ownPos + 1);
                            rivalPos = Math.max(0, rivalPos - 1);
                            gameMessageDiv.textContent += ` ¡Tú ganas! Avanzas 1, rival retrocede 1.`;
                            console.log("DEBUG: Influencer: Gana propio. Posiciones:", ownPos, rivalPos);
                        } else if (rivalHighestCard.value > ownHighestCard.value) {
                            ownPos = Math.max(0, ownPos - 1);
                            rivalPos = Math.min(13, rivalPos + 1);
                            gameMessageDiv.textContent += ` ¡El rival gana! Tú retrocedes 1, rival avanza 1.`;
                            console.log("DEBUG: Influencer: Gana rival. Posiciones:", ownPos, rivalPos);
                        } else {
                            gameMessageDiv.textContent += ` Empate. Nadie avanza ni retrocede.`;
                            console.log("DEBUG: Influencer: Empate.");
                        }
                    } else {
                        gameMessageDiv.textContent = 'No se pudieron encontrar las cartas más altas para la comparación.';
                        console.log("DEBUG: Influencer: No se pudieron encontrar las cartas más altas.");
                    }
                    break;

                case 'camello':
                    console.log("DEBUG: Efecto Camello activado.");
                    const newCardCamello = drawCardForEffect();
                    if (newCardCamello) ownHand.push(newCardCamello);
                    gameMessageDiv.textContent = 'Has robado una carta. Ahora descarta una.';
                    if (ownHand.length > 0) {
                        const discardedCardsCamello = await chooseCardsToDiscard(ownHand, 1, ownNameDisplay.textContent);
                        if (discardedCardsCamello && discardedCardsCamello.length > 0) {
                            const discardedCardId = discardedCardsCamello[0];
                            const index = ownHand.indexOf(discardedCardId);
                            if (index > -1) {
                                ownHand.splice(index, 1);
                                pilaDescarte.push(discardedCardId);
                                const discardedCardCamelloDef = cardDefinitions.find(c => c.id === discardedCardId);
                                gameMessageDiv.textContent += ` Has descartado ${discardedCardCamelloDef.name}.`;
                                console.log("DEBUG: Camello: Carta descartada:", discardedCardCamelloDef.name);
                                if (discardedCardCamelloDef && discardedCardCamelloDef.value <= -1) {
                                    ownPos = Math.min(13, ownPos + 1);
                                    gameMessageDiv.textContent += ' ¡Y avanzas 1 casilla!';
                                    console.log("DEBUG: Camello: Avanza 1 casilla. Nueva posición:", ownPos);
                                }
                            }
                        } else {
                            gameMessageDiv.textContent += ' No se seleccionó ninguna carta para descartar.';
                            console.log("DEBUG: Camello: No se seleccionó ninguna carta para descartar.");
                        }
                    } else {
                        gameMessageDiv.textContent += ' No tienes cartas para descartar.';
                        console.log("DEBUG: Camello: No hay cartas para descartar.");
                    }
                    break;

                case 'trabajador':
                    console.log("DEBUG: Efecto Trabajador activado.");
                    ownPos = Math.min(13, ownPos + 1);
                    gameMessageDiv.textContent += ' ¡Has avanzado 1 casilla!';
                    console.log("DEBUG: Trabajador: Nueva posición:", ownPos);
                    break;

                case 'artesano':
                    console.log("DEBUG: Efecto Artesano activado.");
                    if (ownPos >= 0 && ownPos <= 3) {
                        ownPos = Math.min(13, ownPos + 2);
                        gameMessageDiv.textContent += ' Avanzas 2 casillas.';
                    } else if (ownPos >= 4) {
                        ownPos = Math.min(13, ownPos + 1);
                        gameMessageDiv.textContent += ' Avanzas 1 casilla.';
                    }
                    console.log("DEBUG: Artesano: Nueva posición:", ownPos);
                    break;

                case 'policia':
                    console.log("DEBUG: Efecto Policía activado.");
                    const targetPlayerIdPolicia = await choosePlayer(); // Elegir rival
                    if (isEffectBlockedByGuardaespaldas(targetPlayerIdPolicia)) {
                        gameMessageDiv.textContent = `${opponentNameDisplay.textContent} está protegido por Guardaespaldas. ¡El efecto Policía es bloqueado!`;
                        console.log("DEBUG: Policía: Efecto bloqueado por Guardaespaldas.");
                        break; // Salir del efecto
                    }

                    if (targetPlayerIdPolicia === currentUserId) {
                        ownPos = Math.max(0, ownPos - 1);
                        gameMessageDiv.textContent = 'Has retrocedido 1 casilla.';
                        console.log("DEBUG: Policía: Propio retrocede 1. Nueva posición:", ownPos);
                    } else {
                        rivalPos = Math.max(0, rivalPos - 1);
                        gameMessageDiv.textContent = `${opponentNameDisplay.textContent} retrocede 1 casilla.`;
                        console.log("DEBUG: Policía: Rival retrocede 1. Nueva posición:", rivalPos);
                    }
                    break;

                case 'detective':
                    console.log("DEBUG: Efecto Detective activado.");
                    const targetPlayerIdDetective = await choosePlayer(); // Elegir rival
                    const targetHandDetective = (isPlayer1 && targetPlayerIdDetective === currentRivalId) ? rivalHand : ownHand;

                    if (isEffectBlockedByGuardaespaldas(targetPlayerIdDetective)) {
                        gameMessageDiv.textContent = `${opponentNameDisplay.textContent} está protegido por Guardaespaldas. ¡El efecto Detective es bloqueado!`;
                        console.log("DEBUG: Detective: Efecto bloqueado por Guardaespaldas.");
                        break; // Salir del efecto
                    }

                    const chosenCardIdDetective = await chooseCardFromAllDefinitions('Elige una carta para buscar en la mano del rival:');
                    const cardToFind = cardDefinitions.find(c => c.id === chosenCardIdDetective);

                    if (cardToFind && targetHandDetective.includes(cardToFind.id)) {
                        gameMessageDiv.textContent = `${(targetPlayerIdDetective === currentUserId) ? ownNameDisplay.textContent : opponentNameDisplay.textContent} tiene la carta ${cardToFind.name} y retrocede 2 casillas.`;
                        if (targetPlayerIdDetective === currentUserId) {
                            ownPos = Math.max(0, ownPos - 2);
                            console.log("DEBUG: Detective: Propio retrocede 2. Nueva posición:", ownPos);
                        } else {
                            rivalPos = Math.max(0, rivalPos - 2);
                            console.log("DEBUG: Detective: Rival retrocede 2. Nueva posición:", rivalPos);
                        }
                    } else {
                        gameMessageDiv.textContent = `${(targetPlayerIdDetective === currentUserId) ? ownNameDisplay.textContent : opponentNameDisplay.textContent} no tiene la carta ${cardToFind ? cardToFind.name : 'seleccionada'}.`;
                        console.log("DEBUG: Detective: Carta no encontrada.");
                    }
                    break;

                case 'guardaespaldas':
                    console.log("DEBUG: Efecto Guardaespaldas activado.");
                    // Activar el efecto para el jugador actual
                    effectsActivos[currentUserId] = { guardaespaldas: true, turnosRestantes: 1 }; // Dura hasta tu próximo turno
                    gameMessageDiv.textContent = '¡Guardaespaldas activado! Estás protegido hasta tu próximo turno.';
                    console.log("DEBUG: Guardaespaldas: Efecto activado para el jugador actual.");
                    break;

                case 'abogado':
                    console.log("DEBUG: Efecto Abogado activado.");
                    const targetPlayerIdAbogado = await choosePlayer(); // Elegir rival
                    // Abogado no es bloqueado por Guardaespaldas, ya que es un intercambio, no un efecto adverso directo.
                    if (targetPlayerIdAbogado === currentUserId) {
                        gameMessageDiv.textContent = 'No puedes intercambiar cartas contigo mismo.';
                        console.log("DEBUG: Abogado: Intento de intercambio consigo mismo.");
                        break;
                    }
                    const tempHand = [...ownHand];
                    ownHand.length = 0;
                    ownHand.push(...rivalHand);
                    rivalHand.length = 0;
                    rivalHand.push(...tempHand);
                    gameMessageDiv.textContent = '¡Has intercambiado manos con el rival!';
                    console.log("DEBUG: Abogado: Manos intercambiadas.");
                    break;

                case 'banquero':
                    console.log("DEBUG: Efecto Banquero activado.");
                    if (lastPlayedCardId) {
                        const lastCard = cardDefinitions.find(c => c.id === lastPlayedCardId);
                        if (lastCard && lastCard.value >= 7) {
                            ownPos = Math.min(13, ownPos + 2);
                            gameMessageDiv.textContent = `La última carta (${lastCard.name}) es >= 7. Avanzas 2 casillas.`;
                            console.log("DEBUG: Banquero: Avanza 2 casillas. Nueva posición:", ownPos);
                        } else {
                            gameMessageDiv.textContent = `La última carta (${lastCard ? lastCard.name : 'ninguna'}) no es >= 7.`;
                            console.log("DEBUG: Banquero: No avanza.");
                        }
                    } else {
                        gameMessageDiv.textContent = 'No hay última carta jugada para Banquero.';
                        console.log("DEBUG: Banquero: No hay última carta.");
                    }
                    break;

                case 'musico':
                    console.log("DEBUG: Efecto Músico activado.");
                    for (let i = 0; i < 2; i++) {
                        const newCard = drawCardForEffect();
                        if (newCard) ownHand.push(newCard);
                    }
                    gameMessageDiv.textContent = 'Has robado 2 cartas. Ahora descarta 2.';
                    if (ownHand.length >= 2) {
                        const discardedCardsMusico = await chooseCardsToDiscard(ownHand, 2, ownNameDisplay.textContent);
                        if (discardedCardsMusico && discardedCardsMusico.length === 2) {
                            discardedCardsMusico.forEach(cardId => {
                                const index = ownHand.indexOf(cardId);
                                if (index > -1) {
                                    ownHand.splice(index, 1);
                                    pilaDescarte.push(cardId);
                                }
                            });
                            gameMessageDiv.textContent += ` Has descartado 2 cartas.`;
                            console.log("DEBUG: Músico: Cartas descartadas.");
                        } else {
                            gameMessageDiv.textContent += ' No se seleccionaron 2 cartas para descartar.';
                            console.log("DEBUG: Músico: No se seleccionaron 2 cartas para descartar.");
                        }
                    } else {
                        gameMessageDiv.textContent += ' No tienes suficientes cartas para descartar.';
                        console.log("DEBUG: Músico: No hay suficientes cartas para descartar.");
                    }
                    break;

                case 'arlequin':
                    console.log("DEBUG: Efecto Arlequín activado.");
                    for (let i = 0; i < 2; i++) {
                        const newCard = drawCardForEffect();
                        if (newCard) ownHand.push(newCard);
                    }
                    gameMessageDiv.textContent = 'Has robado 2 cartas. Ahora descarta 1.';
                    if (ownHand.length >= 1) {
                        const discardedCardsArlequin = await chooseCardsToDiscard(ownHand, 1, ownNameDisplay.textContent);
                        if (discardedCardsArlequin && discardedCardsArlequin.length === 1) {
                            const discardedCardId = discardedCardsArlequin[0];
                            const index = ownHand.indexOf(discardedCardId);
                            if (index > -1) {
                                ownHand.splice(index, 1);
                                pilaDescarte.push(discardedCardId);
                            }
                            gameMessageDiv.textContent += ` Has descartado 1 carta.`;
                            console.log("DEBUG: Arlequín: Carta descartada.");
                        } else {
                            gameMessageDiv.textContent += ' No se seleccionó 1 carta para descartar.';
                            console.log("DEBUG: Arlequín: No se seleccionó 1 carta para descartar.");
                        }
                    } else {
                        gameMessageDiv.textContent += ' No tienes cartas para descartar.';
                        console.log("DEBUG: Arlequín: No hay cartas para descartar.");
                    }
                    break;

                case 'futbolista':
                    console.log("DEBUG: Efecto Futbolista activado.");
                    if (ownHand.length > 0) {
                        const discardedCardsFutbolista = await chooseCardsToDiscard(ownHand, 1, ownNameDisplay.textContent);
                        if (discardedCardsFutbolista && discardedCardsFutbolista.length > 0) {
                            const discardedCardId = discardedCardsFutbolista[0];
                            const index = ownHand.indexOf(discardedCardId);
                            if (index > -1) {
                                ownHand.splice(index, 1);
                                pilaDescarte.push(discardedCardId);
                            }
                            ownPos = Math.min(13, ownPos + 2);
                            gameMessageDiv.textContent = 'Has descartado una carta y avanzado 2 casillas.';
                            console.log("DEBUG: Futbolista: Avanza 2 casillas. Nueva posición:", ownPos);
                        } else {
                            gameMessageDiv.textContent = 'No se seleccionó ninguna carta para descartar.';
                            console.log("DEBUG: Futbolista: No se seleccionó ninguna carta para descartar.");
                        }
                    } else {
                        gameMessageDiv.textContent = 'No tienes cartas para descartar y usar Futbolista.';
                        console.log("DEBUG: Futbolista: No hay cartas para descartar.");
                    }
                    break;

                case 'capo':
                    console.log("DEBUG: Efecto Capo activado.");
                    ownPos = Math.min(13, ownPos + 1);
                    const targetPlayerIdCapo = await choosePlayer(); // Elegir rival

                    if (isEffectBlockedByGuardaespaldas(targetPlayerIdCapo)) {
                        gameMessageDiv.textContent = `${opponentNameDisplay.textContent} está protegido por Guardaespaldas. ¡El efecto de retroceso de Capo es bloqueado!`;
                        console.log("DEBUG: Capo: Efecto de retroceso bloqueado por Guardaespaldas.");
                        // Only the retreat part is blocked, player still advances 1.
                        gameMessageDiv.textContent = `Avanzas 1 casilla. ${opponentNameDisplay.textContent} está protegido por Guardaespaldas.`;
                        break;
                    }

                    if (targetPlayerIdCapo === currentUserId) {
                        ownPos = Math.max(0, ownPos - 1);
                        gameMessageDiv.textContent = 'Avanzas 1, pero luego retrocedes 1 (te elegiste a ti mismo).';
                        console.log("DEBUG: Capo: Propio avanza y retrocede. Nueva posición:", ownPos);
                    } else {
                        rivalPos = Math.max(0, rivalPos - 1);
                        gameMessageDiv.textContent = `Avanzas 1 casilla. ${opponentNameDisplay.textContent} retrocede 1 casilla.`;
                        console.log("DEBUG: Capo: Rival retrocede 1. Nueva posición:", rivalPos);
                    }
                    break;

                case 'politico':
                    console.log("DEBUG: Efecto Político activado.");
                    ownPos = Math.min(13, ownPos + 1); // Avanza 1 casilla siempre

                    const playerChoiceDiv = document.createElement('div');
                    playerChoiceDiv.innerHTML = `
                        <p>¿A quién quieres aplicar el efecto de descartar y robar cartas?</p>
                    `;

                    const chosenPlayerIdPolitico = await showModal(
                        'Efecto Político: Elegir Jugador',
                        playerChoiceDiv,
                        [
                            { text: 'A mí', action: currentUserId },
                            { text: 'Al Rival', action: currentRivalId }
                        ]
                    );

                    let targetHandPolitico;
                    let targetPlayerNamePolitico;

                    if (chosenPlayerIdPolitico === currentUserId) {
                        targetHandPolitico = ownHand;
                        targetPlayerNamePolitico = ownNameDisplay.textContent;
                    } else {
                        targetHandPolitico = rivalHand;
                        targetPlayerNamePolitico = opponentNameDisplay.textContent;
                    }

                    // Político no es bloqueado por Guardaespaldas porque es un descarte y robo, no un efecto adverso directo de posición.
                    const numCardsToRedraw = targetHandPolitico.length;
                    // Discard all cards from the target hand
                    while(targetHandPolitico.length > 0) {
                        pilaDescarte.push(targetHandPolitico.pop());
                    }
                    
                    for (let i = 0; i < numCardsToRedraw; i++) {
                        const newCard = drawCardForEffect();
                        if (newCard) targetHandPolitico.push(newCard);
                    }
                    
                    gameMessageDiv.textContent = `Avanzas 1 casilla. ${targetPlayerNamePolitico} ha descartado y robado cartas.`;
                    console.log("DEBUG: Político: Cartas descartadas/robadas. Propio avanza 1.");
                    
                    // Asegurarse de que las manos se actualicen correctamente en el estado
                    if (chosenPlayerIdPolitico === currentUserId) {
                        ownHand = targetHandPolitico;
                    } else {
                        rivalHand = targetHandPolitico;
                    }
                    break;

                case 'sectario':
                    console.log("DEBUG: Efecto Sectario activado.");
                    const targetPlayerIdSectario = await choosePlayer(); // Elegir rival
                    let targetHandSectario = (isPlayer1 && targetPlayerIdSectario === currentRivalId) ? rivalHand : ownHand;

                    // Crear el contenido HTML para mostrar las cartas del rival
                    const rivalHandDisplayDivSectario = document.createElement('div');
                    rivalHandDisplayDivSectario.classList.add('hand'); // Reutilizar estilos de mano
                    if (targetHandSectario.length > 0) {
                        targetHandSectario.forEach(cardId => {
                            const card = cardDefinitions.find(c => c.id === cardId);
                            if (card) {
                                rivalHandDisplayDivSectario.appendChild(createCardElement(card));
                            }
                        });
                    } else {
                        rivalHandDisplayDivSectario.textContent = 'El rival no tiene cartas en la mano.';
                    }

                    const exchangeDecision = await showModal(
                        'Cartas del Rival (Sectario)',
                        rivalHandDisplayDivSectario,
                        [
                            { text: 'Intercambiar Cartas', action: 'exchange' },
                            { text: 'No Intercambiar', action: 'no_exchange' }
                        ]
                    );

                    if (exchangeDecision === 'exchange') {
                        if (targetPlayerIdSectario !== currentUserId) { // Asegurarse de no intercambiar consigo mismo
                            const tempHand = [...ownHand];
                            ownHand.length = 0;
                            ownHand.push(...targetHandSectario);
                            targetHandSectario.length = 0;
                            targetHandSectario.push(...tempHand);
                            gameMessageDiv.textContent = '¡Has intercambiado manos!';
                            console.log("DEBUG: Sectario: Manos intercambiadas.");
                        } else {
                            gameMessageDiv.textContent = 'No puedes intercambiar contigo mismo.';
                            console.log("DEBUG: Sectario: Intento de intercambio consigo mismo.");
                        }
                    } else {
                        gameMessageDiv.textContent = 'Has decidido no intercambiar cartas.';
                        console.log("DEBUG: Sectario: No se intercambiaron cartas.");
                    }

                    ownPos = Math.min(13, ownPos + 1);
                    if (isPlayer1 && targetPlayerIdSectario === currentRivalId) { rivalHand = targetHandSectario; } else if (targetPlayerIdSectario === currentUserId) { ownHand = targetHandSectario; }
                    break;

                case 'astronauta':
                    console.log("DEBUG: Efecto Astronauta activado.");
                    ownPos = Math.min(13, ownPos + 1);
                    if (ownPos >= 8) {
                        const newCard = drawCardForEffect();
                        if (newCard) ownHand.push(newCard);
                        gameMessageDiv.textContent += ' ¡Y has robado 1 carta!';
                        console.log("DEBUG: Astronauta: Roba 1 carta.");
                    }
                    console.log("DEBUG: Astronauta: Nueva posición:", ownPos);
                    break;

                case 'arcangel':
                    console.log("DEBUG: Efecto Arcángel activado.");
                    ownPos = Math.min(13, ownPos + 1);
                    for (let i = 0; i < 3; i++) {
                        const newCard = drawCardForEffect();
                        if (newCard) ownHand.push(newCard);
                    }
                    gameMessageDiv.textContent = 'Avanzas 1 casilla y robas 3 cartas. Ahora descarta 2.';
                    if (ownHand.length >= 2) {
                        const discardedCardsArcangel = await chooseCardsToDiscard(ownHand, 2, ownNameDisplay.textContent);
                        if (discardedCardsArcangel && discardedCardsArcangel.length === 2) {
                            discardedCardsArcangel.forEach(cardId => {
                                const index = ownHand.indexOf(cardId);
                                if (index > -1) {
                                    ownHand.splice(index, 1);
                                    pilaDescarte.push(cardId);
                                }
                            });
                            gameMessageDiv.textContent += ` Has descartado 2 cartas.`;
                            console.log("DEBUG: Arcángel: Cartas descartadas.");
                        } else {
                            gameMessageDiv.textContent += ' No se seleccionaron 2 cartas para descartar.';
                            console.log("DEBUG: Arcángel: No se seleccionaron 2 cartas para descartar.");
                        }
                    } else {
                        gameMessageDiv.textContent += ' No tienes suficientes cartas para descartar.';
                        console.log("DEBUG: Arcángel: No hay suficientes cartas para descartar.");
                    }
                    break;

                case 'semidios':
                    console.log("DEBUG: Efecto Semidiós activado.");
                    ownPos = Math.min(13, ownPos + 1);
                    gameMessageDiv.textContent += ' Avanzas 1 casilla y repites tu turno.';
                    console.log("DEBUG: Semidiós: Repite turno. Nueva posición:", ownPos);
                    break;

                case 'ojotodove':
                    console.log("DEBUG: Efecto Ojo que todo lo ve activado.");
                    ownPos = Math.min(13, ownPos + 1);

                    // Crear el contenido HTML para mostrar las cartas del rival
                    const rivalHandDisplayDivOjo = document.createElement('div');
                    rivalHandDisplayDivOjo.classList.add('hand'); // Reutilizar estilos de mano
                    if (rivalHand.length > 0) {
                        rivalHand.forEach(cardId => {
                            const card = cardDefinitions.find(c => c.id === cardId);
                            if (card) {
                                rivalHandDisplayDivOjo.appendChild(createCardElement(card));
                            }
                        });
                    } else {
                        rivalHandDisplayDivOjo.textContent = 'El rival no tiene cartas en la mano.';
                    }

                    await showModal(
                        'Cartas del Rival (Ojo que todo lo ve)',
                        rivalHandDisplayDivOjo,
                        [{ text: 'Cerrar', action: 'close' }]
                    );

                    gameMessageDiv.textContent = `Avanzas 1 casilla. Has visto las cartas del rival.`;
                    console.log("DEBUG: Ojo que todo lo ve: Cartas del rival mostradas.");
                    break;

                default:
                    console.warn('DEBUG: Efecto de carta no implementado:', card.name);
                    gameMessageDiv.textContent = `Has jugado ${card.name}.`;
                    break;
            }

            // Asegurarse de que los cambios en las manos y posiciones se reflejen en el objeto de estado
            // Asignar de nuevo las variables locales modificadas al objeto 'state' que se pasó por referencia
            state.ownHand = ownHand;
            state.rivalHand = rivalHand;
            state.ownPos = ownPos;
            state.rivalPos = rivalPos;
            state.mazo = mazo;
            state.pilaDescarte = pilaDescarte;
            state.effectsActivos = effectsActivos; // Update effects in state

            console.log("DEBUG: applyCardEffect - Estado final del efecto:", { ownHand: [...ownHand], rivalHand: [...rivalHand], ownPos, rivalPos, mazo: [...mazo], pilaDescarte: [...pilaDescarte], effectsActivos: {...effectsActivos} });
        }


        // Función para pasar el turno
        async function passTurn() {
            const roomRef = db.collection('SALAS').doc(currentRoomId);
            const roomDoc = await roomRef.get();
            const roomData = roomDoc.data();
            const gameState = roomDoc.data().estadoJuego; // Obtener el estado de juego actualizado

            if (gameState.turnoActual !== currentUserId) {
                gameMessageDiv.textContent = '¡No es tu turno para pasar!';
                return;
            }
            console.log("DEBUG: Pasando turno...");

            // Manejar efecto "Perro" si está activo para el siguiente jugador
            let nextTurnPlayerId = currentRivalId; // Por defecto, el turno pasa al rival
            const updatedEffects = { ...gameState.efectosActivos };

            if (updatedEffects && updatedEffects.nextPlayerLosesTurn) {
                gameMessageDiv.textContent = `${opponentNameDisplay.textContent} pierde su turno por el efecto Perro. ¡Es tu turno de nuevo!`;
                delete updatedEffects.nextPlayerLosesTurn;
                nextTurnPlayerId = currentUserId; // El turno se queda en el mismo jugador
                console.log("DEBUG: Perro: Rival pierde turno, propio repite.");
            } else {
                gameMessageDiv.textContent = `Has pasado el turno. Turno de ${opponentNameDisplay.textContent}.`;
                console.log("DEBUG: Turno pasado al rival.");
            }

            // Reducir duración de efectos temporales (ej. Guardaespaldas)
            if (updatedEffects[currentUserId] && updatedEffects[currentUserId].guardaespaldas) {
                updatedEffects[currentUserId].turnosRestantes--;
                if (updatedEffects[currentUserId].turnosRestantes <= 0) {
                    delete updatedEffects[currentUserId];
                    gameMessageDiv.textContent += ' El efecto Guardaespaldas ha terminado.';
                    console.log("DEBUG: Guardaespaldas: Efecto terminado.");
                }
            }

            // Resetear el estado de robo para el siguiente jugador (o para el mismo si repite turno)
            const newDrawStatus = { ...gameState.drawStatus };
            newDrawStatus[nextTurnPlayerId] = false; // El siguiente jugador podrá robar
            console.log("DEBUG: Estado de robo reseteado para:", nextTurnPlayerId, "a false. newDrawStatus:", newDrawStatus);

            const updatePayload = {
                'estadoJuego.turnoActual': nextTurnPlayerId,
                'estadoJuego.efectosActivos': updatedEffects,
                'estadoJuego.drawStatus': newDrawStatus
            };
            console.log("DEBUG: Payload de actualización de turno:", updatePayload);
            await roomRef.update(updatePayload);
        }

        // Función para reiniciar el estado del juego
        async function resetGame(roomRef, roomData) {
            console.log("DEBUG: Reiniciando el juego...");
            const initialDeck = generateInitialDeck();
            const shuffledDeck = shuffleArray(initialDeck);
            const newHand1 = shuffledDeck.splice(0, 3);
            const newHand2 = shuffledDeck.splice(0, 3);

            const player1Id = roomData.jugador1Id;
            const player2Id = roomData.jugador2Id;

            const updatedGameState = {
                mazo: shuffledDeck,
                pilaDescarte: [],
                manoJugador1: newHand1,
                manoJugador2: newHand2,
                posicionJugador1: 0,
                posicionJugador2: 0,
                ultimaCartaJugada: null,
                turnoActual: Math.random() < 0.5 ? player1Id : player2Id, // Turno aleatorio
                gameStatus: "inProgress",
                ganador: null,
                efectosActivos: {},
                drawStatus: {
                    [player1Id]: false,
                    [player2Id]: false
                },
                rematchStatus: {
                    [player1Id]: false,
                    [player2Id]: false
                }
            };

            try {
                await roomRef.update({ estadoJuego: updatedGameState });
                console.log("DEBUG: Juego reiniciado en Firestore. Transicionando a screen3.");
                showScreen(screen3); // Volver a la pantalla de juego
                gameMessageDiv.textContent = '¡Partida reiniciada! ¡A jugar de nuevo!';
            } catch (error) {
                console.error("Error al reiniciar el juego en Firestore:", error);
                gameMessageDiv.textContent = "Error al reiniciar la partida. Inténtalo de nuevo.";
            }
        }


        // --- Event Listeners ---

        // Lógica para la Pantalla 1: Introducir Nombre de Jugador
        btnEnterName.addEventListener('click', async () => {
            const name = playerNameInput.value.trim();
            const rival = rivalNameInputScreen1.value.trim();

            nameError.textContent = '';
            rivalErrorScreen1.textContent = '';

            let valid = true;
            if (!name) {
                nameError.textContent = 'Por favor, introduce tu nombre.';
                valid = false;
            }

            if (!rival) {
                rivalErrorScreen1.textContent = 'Por favor, introduce el nombre de tu rival.';
                valid = false;
            } else if (name && rival === name) {
                rivalErrorScreen1.textContent = 'No puedes ser tu propio rival. Introduce un nombre diferente.';
                valid = false;
            }

            if (valid) {
                currentPlayerName = name;
                rivalPlayerName = rival;
                console.log(`Tu nombre: ${currentPlayerName}, Nombre del rival: ${rivalPlayerName}`);

                await signInAnonymouslyAndGetUid();
                if (currentUserId) {
                    await findOrCreateRoom(currentPlayerName, rivalPlayerName);
                    // showScreen(screen3) es manejado por findOrCreateRoom o listenToRoomChanges
                } else {
                    nameError.textContent = 'Error de autenticación. Por favor, recarga la página.';
                }
            }
        });


        btnPassTurn.addEventListener('click', passTurn);

        // Event listener para el botón de reinicio en screen2
        btnRematch.addEventListener('click', async () => {
            if (!currentRoomId || !currentUserId) {
                console.error("No hay sala o usuario actual para iniciar el reinicio.");
                return;
            }

            const roomRef = db.collection('SALAS').doc(currentRoomId);
            try {
                // Actualizar el estado de rematch para el jugador actual
                await roomRef.update({
                    [`estadoJuego.rematchStatus.${currentUserId}`]: true
                });
                console.log(`DEBUG: Jugador ${currentUserId} ha marcado como listo para revancha.`);
                // La UI se actualizará vía el onSnapshot listener
            } catch (error) {
                console.error("Error al actualizar estado de revancha:", error);
            }
        });

        // Inicialmente, mostrar la primera pantalla
        showScreen(screen1);

        // Ajustar el tablero cuando la ventana cambia de tamaño
        window.addEventListener('resize', () => {
            if (screen3.classList.contains('active')) {
                // Solo renderizar si la pantalla de juego está activa
                // Necesitamos los valores actuales de posición para re-renderizar
                // Esto requerirá que el estado del juego sea accesible globalmente o se pase
                // Por ahora, solo se re-renderiza con valores por defecto si no hay estado
                // Esta llamada debería idealmente usar el estado actual del juego
                // Para simplificar, asumimos que el updateGameUI se encargará de esto con el onSnapshot
            }
        });

        // Asegurarse de que el tablero se renderice correctamente al cargar la pantalla 3
        // Esto se ejecutará una vez que la pantalla 3 sea activa
        const observer = new MutationObserver((mutationsList, observer) => {
            for (const mutation of mutationsList) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    if (screen3.classList.contains('active')) {
                        // Dar un pequeño retraso para asegurar que el DOM esté listo y los tamaños calculados
                        // Se llama a renderGameBoard con 0,0 aquí, pero el onSnapshot lo actualizará con los valores reales
                        setTimeout(() => {
                            // Si ya hay un roomData disponible, usarlo. Si no, 0,0 es un buen inicio.
                            if (currentRoomId) {
                                db.collection('SALAS').doc(currentRoomId).get().then(doc => {
                                    if (doc.exists) {
                                        const roomData = doc.data();
                                        const ownPos = roomData.jugador1Id === currentUserId ? roomData.estadoJuego.posicionJugador1 : roomData.estadoJuego.posicionJugador2;
                                        const opponentPos = roomData.jugador1Id === currentUserId ? roomData.estadoJuego.posicionJugador2 : roomData.estadoJuego.posicionJugador1;
                                        renderGameBoard(ownPos, opponentPos);
                                    } else {
                                        renderGameBoard(0, 0);
                                    }
                                }).catch(error => {
                                    console.error("Error al obtener datos de la sala para renderizar tablero:", error);
                                    renderGameBoard(0, 0);
                                });
                            } else {
                                renderGameBoard(0, 0);
                            }
                        }, 100);
                    }
                }
            }
        });
        observer.observe(screen3, { attributes: true });

    </script>
</body>
</html>
