<!DOCTYPE html>
<html lang="es">

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aplicación de Videollamada P2P</title>
    <script type="module" src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js"></script>
    <script type="module" src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: black; /* Fondo negro */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            color: #eee; /* Color de texto claro para el fondo oscuro */
            overflow: hidden; /* Evitar scroll si los videos son muy grandes */
        }

        .controls-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 20px; /* Espacio entre los controles */
            margin-bottom: 20px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5); /* Fondo semitransparente para los controles */
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        button {
            padding: 12px 25px;
            border-radius: 8px; /* Bordes redondeados */
            border: none;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 18px;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
            font-size: 1.1em;
        }

        .volume-control input[type="range"] {
            width: 150px;
            height: 8px;
            border-radius: 5px;
            background: #555;
            outline: none;
            -webkit-appearance: none; /* Ocultar el estilo predeterminado del navegador */
            appearance: none;
            cursor: pointer;
        }

        .volume-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .volume-control input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }


        #localVideo,
        #remoteVideo {
            border-radius: 12px; /* Bordes más redondeados */
            margin: 5px; /* Espacio mínimo entre videos */
            width: 49vw; /* Ocupa casi la mitad del ancho de la ventana */
            height: 80vh; /* Ocupa casi todo el alto de la ventana */
            object-fit: cover; /* Asegura que el video cubra el área sin distorsión */
            border: 3px solid #007bff;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.5); /* Sombra más pronunciada */
            background-color: #000; /* Fondo negro para videos si no hay stream */
        }

        .video-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center; /* Centra los videos verticalmente */
            width: 100vw; /* Ocupa todo el ancho de la ventana */
            height: 85vh; /* Ocupa la mayor parte del alto de la ventana */
            margin-top: 0; /* Eliminar margen superior */
        }

        /* Estilo para el mensaje de error/información */
        #cameraStatusMessage {
            color: #dc3545; /* Rojo para errores */
            margin-top: 10px;
            font-size: 1.1em;
            text-align: center;
            padding: 10px;
            border-radius: 5px;
            background-color: #ffebe8;
            border: 1px solid #dc3545;
            display: none; /* Oculto por defecto */
        }

        /* Ajustes responsivos */
        @media (max-width: 768px) {
            .video-container {
                flex-direction: column; /* Apila los videos en pantallas pequeñas */
                height: auto; /* Altura automática para permitir el scroll si es necesario */
            }
            #localVideo,
            #remoteVideo {
                width: 95vw; /* Ocupa casi todo el ancho en móvil */
                height: 40vh; /* Altura ajustada para móvil */
                margin: 5px 0;
            }
            .controls-container {
                flex-direction: column;
                gap: 10px;
            }
            .volume-control input[type="range"] {
                width: 100px;
            }
        }
    </style>
</head>

<body>
    <div class="controls-container">
        <button id="btn-toggle-camera">Desactivar cámara</button>
        <div class="volume-control">
            <label for="volumeSlider">Micrófono:</label>
            <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1">
        </div>
    </div>
    <div id="cameraStatusMessage"></div>
    <div class="video-container">
        <video id="localVideo" autoplay playsinline muted></video>
        <video id="remoteVideo" autoplay playsinline></video>
    </div>


    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, remove } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";

        let peer = null; // Inicializar peer a null
        let localStream = null; // Stream local que se envía y se muestra
        let originalLocalMediaStream = null; // El stream original de getUserMedia
        let remotePeerId = null; // Para rastrear el ID del peer remoto conectado
        let callInProgress = false; // Bandera para evitar múltiples llamadas
        let reconnectionAttemptInterval = null; // Para almacenar el ID del intervalo de reconexión
        const RECONNECTION_INTERVAL_MS = 3000; // Intervalo de chequeo de reconexión (3 segundos)
        let isPeerConnecting = false; // Nueva bandera para evitar múltiples llamadas a initializePeer

        // Variables para el control de volumen del micrófono
        let audioContext = null;
        let microphoneSource = null;
        let gainNode = null;
        let mediaStreamDestination = null;

        const btnToggleCamera = document.getElementById("btn-toggle-camera");
        const localVideo = document.getElementById("localVideo");
        const remoteVideo = document.getElementById("remoteVideo");
        const cameraStatusMessage = document.getElementById("cameraStatusMessage");
        const volumeSlider = document.getElementById('volumeSlider'); // Nuevo: Slider de volumen

        // Configuración de Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyAfK_AOq-Pc2bzgXEzIEZ1ESWvnhMJUvwI",
            authDomain: "enraya-51670.firebaseapp.com",
            databaseURL: "https://enraya-51670-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "enraya-51670",
            storageBucket: "enraya-51670.firebasestorage.app",
            messagingSenderId: "103343380727",
            appId: "1:103343380727:web:b2fa02aee03c9506915bf2",
            measurementId: "G-2G31LLJY1T"
        };

        // Inicializar Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // ID de la sala para la conexión automática de 2 personas
        const ROOM_ID = "twoPersonVideoChat";

        /**
         * Muestra un mensaje de estado en la interfaz de usuario.
         * @param {string} message - El mensaje a mostrar.
         * @param {string} type - El tipo de mensaje ('info', 'error', 'success').
         */
        function showStatusMessage(message, type = 'info') {
            cameraStatusMessage.textContent = message;
            cameraStatusMessage.style.display = 'block';
            if (type === 'error') {
                cameraStatusMessage.style.color = '#dc3545';
                cameraStatusMessage.style.borderColor = '#dc3545';
                cameraStatusMessage.style.backgroundColor = '#ffebe8';
            } else if (type === 'info') {
                cameraStatusMessage.style.color = '#0056b3';
                cameraStatusMessage.style.borderColor = '#007bff';
                cameraStatusMessage.style.backgroundColor = '#e0f2ff';
            } else if (type === 'success') {
                cameraStatusMessage.style.color = '#28a745';
                cameraStatusMessage.style.borderColor = '#28a745';
                cameraStatusMessage.style.backgroundColor = '#e6ffe6';
            }
        }

        /**
         * Oculta el mensaje de estado.
         */
        function hideStatusMessage() {
            cameraStatusMessage.style.display = 'none';
        }

        /**
         * Configura el stream local con control de volumen.
         * @param {MediaStream} stream - El stream original de getUserMedia.
         */
        function setupLocalStreamWithVolumeControl(stream) {
            // Detener y cerrar el contexto de audio anterior si existe
            if (audioContext) {
                audioContext.close();
            }

            originalLocalMediaStream = stream; // Guardar el stream original

            const audioTrack = stream.getAudioTracks()[0];
            const videoTrack = stream.getVideoTracks()[0];

            if (audioTrack) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                microphoneSource = audioContext.createMediaStreamSource(new MediaStream([audioTrack]));
                gainNode = audioContext.createGain();
                mediaStreamDestination = audioContext.createMediaStreamDestination();

                microphoneSource.connect(gainNode);
                gainNode.connect(mediaStreamDestination);

                // Crear un nuevo stream que combina el video original con el audio controlado por el GainNode
                localStream = new MediaStream([videoTrack, mediaStreamDestination.stream.getAudioTracks()[0]]);
                gainNode.gain.value = parseFloat(volumeSlider.value); // Establecer el volumen inicial del slider
            } else {
                // Si no hay pista de audio, simplemente usar el stream original
                localStream = stream;
                console.warn("No se encontró pista de audio en el stream local.");
            }

            localVideo.srcObject = localStream;
            localVideo.onloadedmetadata = () => localVideo.play();
        }

        /**
         * Intenta reinicializar la conexión PeerJS si está desconectada o no inicializada.
         */
        function handlePeerReconnection() {
            if (isPeerConnecting) {
                console.log("Ya hay un intento de conexión en curso. Esperando...");
                return;
            }

            // Si PeerJS no está inicializado o está desconectado
            if (!peer || peer.disconnected) {
                console.log("PeerJS desconectado o no inicializado. Intentando reconectar...");
                // Destruir la instancia de peer existente si existe y no está ya destruida
                if (peer && !peer.destroyed) {
                    console.log("Destruyendo instancia de PeerJS existente para reconectar.");
                    peer.destroy();
                    peer = null; // Establecer a null para forzar una nueva creación
                }
                initializePeer(); // Reinicializar PeerJS
            } else if (peer.open) {
                // Si el peer está abierto, podemos detener el chequeo de reconexión si no es necesario
                stopReconnectionCheck();
            }
        }

        /**
         * Inicia el chequeo periódico de reconexión.
         */
        function startReconnectionCheck() {
            if (!reconnectionAttemptInterval) {
                reconnectionAttemptInterval = setInterval(handlePeerReconnection, RECONNECTION_INTERVAL_MS);
                console.log(`Iniciando chequeo de reconexión cada ${RECONNECTION_INTERVAL_MS / 1000} segundos.`);
            }
        }

        /**
         * Detiene el chequeo periódico de reconexión.
         */
        function stopReconnectionCheck() {
            if (reconnectionAttemptInterval) {
                clearInterval(reconnectionAttemptInterval);
                reconnectionAttemptInterval = null;
                console.log("Deteniendo chequeo de reconexión.");
            }
        }

        /**
         * Inicializa PeerJS y maneja la lógica de conexión automática.
         */
        function initializePeer() {
            if (isPeerConnecting) {
                console.log("initializePeer: Ya hay un intento de conexión en curso. Abortando.");
                return;
            }
            isPeerConnecting = true; // Establecer la bandera para indicar que hay un intento de conexión

            // Si ya existe una instancia de peer y no está destruida, destruirla para evitar conflictos
            if (peer && !peer.destroyed) {
                console.log("initializePeer: Destruyendo instancia de PeerJS existente antes de crear una nueva.");
                peer.destroy();
                peer = null; // Establecer a null después de destruir
            }

            peer = new Peer();

            // Evento cuando el PeerJS está abierto y se obtiene un ID
            peer.on("open", id => {
                console.log("Mi ID de Peer:", id);
                isPeerConnecting = false; // Restablecer la bandera ya que la conexión se ha abierto
                stopReconnectionCheck(); // Detener el chequeo de reconexión una vez conectado
                startReconnectionCheck(); // Y luego reiniciarlo para monitorear futuras desconexiones
                showStatusMessage("Conectado al servidor de señalización. Esperando otro usuario...", 'info');


                // Registrar el ID del peer actual en Firebase
                const peerRef = ref(database, `rooms/${ROOM_ID}/peers/${id}`);
                set(peerRef, true) // Establecer un valor simple para indicar la presencia
                    .then(() => {
                        console.log(`Peer ${id} registrado en la sala ${ROOM_ID}`);
                    })
                    .catch(error => {
                        console.error("Error al registrar el peer en Firebase:", error);
                        showStatusMessage("Error al registrar el usuario en la sala.", 'error');
                    });

                // Escuchar a otros peers que se unen a la sala
                const peersInRoomRef = ref(database, `rooms/${ROOM_ID}/peers`);
                onValue(peersInRoomRef, (snapshot) => {
                    const peers = snapshot.val();
                    if (peers) {
                        const peerIds = Object.keys(peers);
                        console.log("Peers en la sala:", peerIds);

                        // Encontrar el otro peer (que no sea el actual)
                        const otherPeerFound = peerIds.find(peerId => peerId !== id);

                        if (otherPeerFound && !callInProgress) {
                            remotePeerId = otherPeerFound;
                            console.log("Otro peer encontrado:", remotePeerId, ". Iniciando llamada...");
                            callInProgress = true;
                            stopReconnectionCheck(); // Detener el chequeo de reconexión una vez que se inicia una llamada
                            showStatusMessage("Otro usuario encontrado. Iniciando videollamada...", 'info');
                            try {
                                // Verificar si el stream local está disponible antes de llamar
                                if (!localStream) {
                                    console.error("No hay stream local disponible para iniciar la llamada.");
                                    callInProgress = false; // Restablecer la bandera
                                    startReconnectionCheck(); // Reanudar el chequeo de reconexión
                                    showStatusMessage("Error: No se pudo iniciar la llamada. Acceso a la cámara/micrófono denegado o no disponible.", 'error');
                                    return; // Salir temprano
                                }
                                // Usar el localStream con control de volumen
                                const call = peer.call(remotePeerId, localStream);
                                // Manejar el stream del peer remoto
                                call.on("stream", stream => {
                                    remoteVideo.srcObject = stream;
                                    remoteVideo.onloadedmetadata = () => remoteVideo.play();
                                    console.log("Stream remoto recibido.");
                                    hideStatusMessage(); // Ocultar mensaje de estado cuando la llamada está activa
                                });
                                // Manejar el cierre de la llamada
                                call.on("close", () => {
                                    console.log("Llamada cerrada.");
                                    callInProgress = false;
                                    remoteVideo.srcObject = null;
                                    startReconnectionCheck(); // Reiniciar el chequeo cuando la llamada termina
                                    showStatusMessage("Videollamada finalizada. Esperando otro usuario...", 'info');
                                });
                                // Manejar errores de la llamada
                                call.on("error", (err) => {
                                    console.error("Error en la llamada:", err);
                                    callInProgress = false;
                                    remoteVideo.srcObject = null;
                                    startReconnectionCheck(); // Reiniciar el chequeo en caso de error en la llamada
                                    showStatusMessage("Error en la videollamada. Intentando reconectar...", 'error');
                                });
                            } catch (err) {
                                console.error("Error al iniciar la llamada:", err);
                                callInProgress = false;
                                startReconnectionCheck(); // Reiniciar el chequeo en caso de error al iniciar la llamada
                                showStatusMessage("Error al iniciar la videollamada. Intentando reconectar...", 'error');
                            }
                        } else if (!otherPeerFound && callInProgress) {
                            // Si el peer remoto desaparece mientras la llamada está en curso, finalizar la llamada
                            console.log("Otro peer desaparecido mientras la llamada estaba en curso.");
                            callInProgress = false;
                            remotePeerId = null;
                            if (remoteVideo) remoteVideo.srcObject = null;
                            startReconnectionCheck(); // Reiniciar el chequeo
                            showStatusMessage("El otro usuario se ha desconectado. Esperando otro usuario...", 'info');
                        } else if (!otherPeerFound) {
                            console.log("Esperando a otro peer para unirse...");
                            callInProgress = false;
                            remotePeerId = null;
                            if (remoteVideo) remoteVideo.srcObject = null;
                            startReconnectionCheck(); // Asegurarse de que el chequeo esté funcionando si no hay otro peer
                            showStatusMessage("Esperando otro usuario para unirse a la sala...", 'info');
                        }
                    } else {
                        console.log("Aún no hay peers en la sala. Esperando...");
                        callInProgress = false;
                        remotePeerId = null;
                        if (remoteVideo) remoteVideo.srcObject = null;
                        startReconnectionCheck(); // Asegurarse de que el chequeo esté funcionando si no hay peers
                        showStatusMessage("Aún no hay usuarios en la sala. Esperando el primer usuario...", 'info');
                    }
                });

                // Limpiar el ID del peer de Firebase cuando la página se cierra o se recarga
                window.addEventListener('beforeunload', () => {
                    const selfPeerRef = ref(database, `rooms/${ROOM_ID}/peers/${id}`);
                    remove(selfPeerRef)
                        .then(() => {
                            console.log(`Peer ${id} eliminado de Firebase.`);
                        })
                        .catch(error => {
                            console.error("Error al eliminar el peer de Firebase:", error);
                        });
                    // Cerrar el contexto de audio al salir
                    if (audioContext) {
                        audioContext.close();
                    }
                });
            });

            // Evento cuando se recibe una llamada
            peer.on("call", call => {
                console.log("Llamada entrante de:", call.peer);
                callInProgress = true;
                stopReconnectionCheck(); // Detener el chequeo de reconexión una vez que se recibe una llamada
                showStatusMessage("Recibiendo videollamada...", 'info');
                // Verificar si el stream local está disponible antes de responder
                if (!localStream) {
                    console.error("No hay stream local disponible para responder a la llamada.");
                    callInProgress = false; // Restablecer la bandera
                    startReconnectionCheck(); // Reanudar el chequeo de reconexión
                    call.close(); // Cerrar la llamada entrante si no hay stream local
                    showStatusMessage("Error: No se pudo responder a la llamada. Acceso a la cámara/micrófono denegado o no disponible.", 'error');
                    return; // Salir temprano
                }
                // Responder a la llamada con el localStream con control de volumen
                call.answer(localStream);
                call.on("stream", stream => {
                    remoteVideo.srcObject = stream;
                    remoteVideo.onloadedmetadata = () => remoteVideo.play();
                    console.log("Stream remoto recibido en llamada entrante.");
                    hideStatusMessage(); // Ocultar mensaje de estado cuando la llamada está activa
                });
                call.on("close", () => {
                    console.log("Llamada cerrada.");
                    callInProgress = false;
                    remoteVideo.srcObject = null;
                    startReconnectionCheck(); // Reiniciar el chequeo cuando la llamada termina
                    showStatusMessage("Videollamada finalizada. Esperando otro usuario...", 'info');
                });
                call.on("error", (err) => {
                    console.error("Error en la llamada entrante:", err);
                    callInProgress = false;
                    remoteVideo.srcObject = null;
                    startReconnectionCheck(); // Reiniciar el chequeo en caso de error en la llamada
                    showStatusMessage("Error en la videollamada. Intentando reconectar...", 'error');
                });
            });

            // Evento cuando PeerJS se desconecta
            peer.on("disconnected", () => {
                console.log("Peer desconectado.");
                callInProgress = false;
                remotePeerId = null;
                if (remoteVideo) remoteVideo.srcObject = null;
                showStatusMessage("Desconectado del servidor de señalización. Intentando reconectar...", 'error');
                startReconnectionCheck(); // Asegurarse de que el chequeo de reconexión esté funcionando
            });

            // Evento cuando ocurre un error en PeerJS
            peer.on("error", (err) => {
                console.error("Error de PeerJS:", err);
                isPeerConnecting = false; // Restablecer la bandera en caso de error
                showStatusMessage(`Error de conexión: ${err.message}. Asegúrate de que el archivo se sirve desde un servidor web (no 'file:///').`, 'error');
                startReconnectionCheck();
            });

            // Acceso inicial a la cámara y el micrófono
            navigator.mediaDevices.getUserMedia({ video: true, audio: true })
                .then(stream => {
                    setupLocalStreamWithVolumeControl(stream); // Configurar el stream con control de volumen
                    btnToggleCamera.textContent = "Desactivar cámara";
                    hideStatusMessage(); // Ocultar mensaje si la cámara se activa correctamente
                })
                .catch(err => {
                    console.error("Error al acceder a la cámara y el micrófono: ", err);
                    btnToggleCamera.textContent = "Activar cámara"; // Si falla, el botón debe decir "Activar"
                    showStatusMessage("Error al acceder a la cámara/micrófono. Asegúrate de que el archivo se sirve desde un servidor web (no 'file:///'), y que has concedido los permisos.", 'error');
                    startReconnectionCheck(); // Si falla el acceso a los medios, mantener el chequeo de reconexión de PeerJS
                });
        }

        // Manejar el botón de alternar cámara
        btnToggleCamera.addEventListener("click", function() {
            if (localStream) {
                // Detener todas las pistas del stream original para liberar recursos
                if (originalLocalMediaStream) {
                    originalLocalMediaStream.getTracks().forEach(track => track.stop());
                }
                // Cerrar el contexto de audio
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                    microphoneSource = null;
                    gainNode = null;
                    mediaStreamDestination = null;
                }

                localStream = null;
                originalLocalMediaStream = null;
                localVideo.srcObject = null;
                btnToggleCamera.textContent = "Activar cámara";
                showStatusMessage("Cámara y micrófono desactivados.", 'info');
                // Si se desactiva la cámara, también debería finalizar la llamada si está en curso
                if (peer && peer.connections) {
                    for (let conns in peer.connections) {
                        peer.connections[conns].forEach(conn => {
                            if (conn.type === 'media' && conn.open) {
                                conn.close();
                            }
                        });
                    }
                }
            } else {
                navigator.mediaDevices.getUserMedia({ video: true, audio: true })
                    .then(stream => {
                        setupLocalStreamWithVolumeControl(stream); // Configurar el stream con control de volumen
                        btnToggleCamera.textContent = "Desactivar cámara";
                        hideStatusMessage(); // Ocultar mensaje si la cámara se activa correctamente
                        // Si se activa la cámara, intentar reconectar si hay un peer remoto
                        if (remotePeerId && !callInProgress) {
                            console.log("Cámara activada, intentando reconectar con:", remotePeerId);
                            callInProgress = true;
                            try {
                                // Usar el localStream con control de volumen
                                const call = peer.call(remotePeerId, localStream);
                                call.on("stream", stream => {
                                    remoteVideo.srcObject = stream;
                                    remoteVideo.onloadedmetadata = () => remoteVideo.play();
                                });
                                call.on("close", () => {
                                    console.log("Llamada cerrada después de reconexión.");
                                    callInProgress = false;
                                    remoteVideo.srcObject = null;
                                });
                                call.on("error", (err) => {
                                    console.error("Error en la llamada de reconexión:", err);
                                    callInProgress = false;
                                    remoteVideo.srcObject = null;
                                });
                            } catch (err) {
                                console.error("Error al iniciar la llamada de reconexión:", err);
                                callInProgress = false;
                            }
                        }
                    })
                    .catch(err => {
                        console.error("Error al acceder a la cámara y el micrófono: ", err);
                        showStatusMessage("Error al acceder a la cámara/micrófono. Asegúrate de que el archivo se sirve desde un servidor web (no 'file:///'), y que has concedido los permisos.", 'error');
                    });
            }
        });

        // Nuevo: Event listener para el slider de volumen
        volumeSlider.addEventListener('input', (event) => {
            if (gainNode) {
                gainNode.gain.value = parseFloat(event.target.value);
                console.log("Volumen del micrófono establecido a:", gainNode.gain.value);
            }
        });


        // Iniciar la inicialización de PeerJS cuando la ventana se carga
        window.onload = function() {
            initializePeer();
        };
    </script>

</body>

</html>
